from secp256k1 import * 
import struct
import random
import hashlib
import sha3
import binascii
import ecdsa
from ecdsa import SigningKey, VerifyingKey
from six import b
from ecdsa.ellipticcurve import CurveFp, INFINITY, Point
import time


from ethjsonrpc import EthJsonRpc
from ethjsonrpc.constants import BLOCK_TAGS, BLOCK_TAG_EARLIEST, BLOCK_TAG_LATEST

debug = True
rangSigBool = True
MAX_AMOUNT = 2**64;
MAX_MIXIN = 100; 
crv=ecdsa.SECP256k1
g = SigningKey.generate(curve=crv)
P = 2**256 - 2**32 - 2**9 - 2**8 - 2**7 - 2**6 - 2**4 - 1
G = "0479BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8"
curveOrder = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141"

connection = EthJsonRpc('localhost', 8545)
contractAddress = "0xa7b1800d46dd564278053eeb06cbdfdce3798c98" 
ATOMS = 64

def hash_to_point(pubK):
    return g.from_string(hashlib.sha256(pubK).digest(), curve=crv).verifying_key

def hash_to_point_special(pubK):
    p = VerifyingKey.from_string(pubK).pubkey.point
    return hash_to_point(to_32_bytes_number(p.x())+ to_32_bytes_number(p.y()))

def to_32_bytes_number (val, endianness='big'):
    # see https://stackoverflow.com/questions/8730927/convert-python-long-int-to-fixed-size-byte-array/28057222
    fmt = '%%0%dx' % 64
    s = binascii.unhexlify(fmt % val)
    if endianness == 'little':
        # see http://stackoverflow.com/a/931095/309233
        s = s[::-1]
    return s

def to_int_from_bytes(val, endianness= 'big'):
    return int.from_bytes(val, byteorder=endianness)

def add_2_32b(a, b):
    return to_32_bytes_number((to_int_from_bytes(a) + to_int_from_bytes(b)) % crv.order)

def sub_2_32b(a, b):
    return to_32_bytes_number((to_int_from_bytes(a) - to_int_from_bytes(b)) % crv.order)

# def create_contract():
#     compiled = "60606040527f79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f817986000557f483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b860015560406040519081016040528060005481526020016001548152506002906002610076929190610120565b5060206040519081016040528060026002806020026040519081016040528092919082600280156100bc576020028201915b8154815260200190600101908083116100a8575b505050505081525060046000820151816000019060026100dd929190610160565b5050507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f600655600560075560066008556007600955341561011b57fe5b6101c5565b826002810192821561014f579160200282015b8281111561014e578251825591602001919060010190610133565b5b50905061015c91906101a0565b5090565b826002810192821561018f579160200282015b8281111561018e578251825591602001919060010190610173565b5b50905061019c91906101a0565b5090565b6101c291905b808211156101be5760008160009055506001016101a6565b5090565b90565b610890806101d46000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680637422d36414610046578063ecd31f60146102e9575bfe5b341561004e57fe5b610166600480803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190803590602001908201803590602001908080601f016020809104026020016040519081016040528093929190818152602001838380828437820191505050505050919080359060200190919080359060200190820180359060200190808060200260200160405190810160405280939291908181526020016000905b82821015610158578484839050604002016002806020026040519081016040528092919082600260200280828437820191505050505081526020019060010190610113565b5050505050919050506104b5565b604051808060200180602001858152602001806020018481038452888181518152602001915080519060200190808383600083146101c3575b8051825260208311156101c35760208201915060208101905060208303925061019f565b505050905090810190601f1680156101ef5780820380516001836020036101000a031916815260200191505b50848103835287818151815260200191508051906020019080838360008314610237575b80518252602083111561023757602082019150602081019050602083039250610213565b505050905090810190601f1680156102635780820380516001836020036101000a031916815260200191505b508481038252858181518152602001915080516000925b818410156102d3578284906020019060200201516002602002808383600083146102c3575b8051825260208311156102c35760208201915060208101905060208303925061029f565b505050905001926001019261027a565b9250505097505050505050505060405180910390f35b34156102f157fe5b6104b3600480803590602001908201803590602001908080601f016020809104026020016040519081016040528093929190818152602001838380828437820191505050505050919080359060200190919080359060200190919080359060200190820180359060200190808060200260200160405190810160405280939291908181526020016000905b828210156103c157848483905060400201600280602002604051908101604052809291908260026020028082843782019150505050508152602001906001019061037c565b50505050509190803560001916906020019091908035906020019091908035906020019091908035906020019082018035906020019080806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050919080359060200190919080359060200190820180359060200190808060200260200160405190810160405280939291908181526020016000905b828210156104a5578484839050604002016002806020026040519081016040528092919082600260200280828437820191505050505081526020019060010190610460565b5050505050919050506106c9565b005b6104bd61083c565b6104c561083c565b60006104cf610850565b7f551303dd5f39cbfe6daba6b3e27754b8a7d72f519756a2cde2b92c2bbde159a76040518080602001828103825260138152602001807f2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d0000000000000000000000000081525060200191505060405180910390a17f43123f7005ece31cd2478fa2cd0bec5ea2e353c1c3fe9ca390a6de2ab917eac96040518080602001828103825260168152602001807f576520676f742061206e696365206d6573736167653a0000000000000000000081525060200191505060405180910390a17f43123f7005ece31cd2478fa2cd0bec5ea2e353c1c3fe9ca390a6de2ab917eac9886040518080602001828103825283818151815260200191508051906020019080838360008314610610575b805182526020831115610610576020820191506020810190506020830392506105ec565b505050905090810190601f16801561063c5780820380516001836020036101000a031916815260200191505b509250505060405180910390a17f43123f7005ece31cd2478fa2cd0bec5ea2e353c1c3fe9ca390a6de2ab917eac96040518080602001828103825260138152602001807f2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d0000000000000000000000000081525060200191505060405180910390a18787878793509350935093505b945094509450949050565b6000600088518a8c02141515610768577f551303dd5f39cbfe6daba6b3e27754b8a7d72f519756a2cde2b92c2bbde159a760405180806020018281038252602b8152602001807f4d69736d6174636820696e207468652064696d656e73696f6e206f662074686581526020017f206b6579206d617472697800000000000000000000000000000000000000000081525060400191505060405180910390a15b7f43123f7005ece31cd2478fa2cd0bec5ea2e353c1c3fe9ca390a6de2ab917eac98c60405180806020018281038252838181518152602001915080519060200190808383600083146107d9575b8051825260208311156107d9576020820191506020810190506020830392506107b5565b505050905090810190601f1680156108055780820380516001836020036101000a031916815260200191505b509250505060405180910390a1600090505b8381101561082d575b8080600101915050610817565b5b505050505050505050505050565b602060405190810160405280600081525090565b6020604051908101604052806000815250905600a165627a7a72305820a5fa078f0f18cb8426d0c3bc94628d48f90145b19b0de014beb6764f4c00e7ca0029"
#     blockNumber = connection.eth_blockNumber()
#     contract_tx = connection.create_contract(connection.eth_coinbase(), compiled, gas=300000)
#     print("tx " + contract_tx)
#     contract_addr = connection.eth_getTransactionReceipt(contract_tx)
#     while(contract_addr == None):
#         print("waiting")
#         time.sleep(0.5)
#         contract_addr = connection.eth_getTransactionReceipt(contract_tx)
#     global contractAddress
#     contractAddress = connection.get_contract_address(contract_tx)
#     print("addre" + contractAddress)

def send_ring(message, pubkey, c0, ss, II):
    print("------ Preparing to send transaction  -------")
    filterNames = ['Log Error', 'Print string', 'Print bool', 'Print address', 'Print uint256', 'PrintStringAndUint(string,uint256)']
    to_keccack = ["LogErrorString(string)", "PrintString(string)", "PrintBool(bool)", "PrintAddress(address)", "PrintUint(uint256)", "PrintStringAndUint(string,uint256)"]
    keccack = []
    for i in range(0, len(to_keccack)):
        keccack.append(connection.web3_sha3(to_keccack[i]))

    filter = []
    for i in range(0, len(keccack)):
        filter.append(connection.eth_newFilter(from_block='earliest', address=contractAddress, topics=[keccack[i]]))

    pubkeysAlligned = []
    for i in range(0, len(pubkey)):
        for j in range(0, len(pubkey[0])):
            pk = VerifyingKey.from_string(pubkey[i][j]).pubkey.point
            pubkeysAlligned.append([to_32_bytes_number(pk.x()), to_32_bytes_number(pk.y())])

    ssAlligned = []
    for i in range(0, len(ss)):
        for j in range(0, len(ss[0])):
            ssAlligned.append(ss[i][j])

    IIAlligned = []
    for i in range(0, len(II)):
        I = VerifyingKey.from_string(II[i]).pubkey.point
        IIAlligned.append([to_32_bytes_number(I.x()), to_32_bytes_number(I.y())])



    cb = connection.eth_coinbase()
    results = connection.call_with_transaction(cb, contractAddress, 
        # 'y()',[])
        'testb(string,uint256,uint256,bytes32[2][],bytes32,uint256,uint256,bytes32[],uint256,bytes32[2][])',\
        [message,\
        len(pubkey), len(pubkey[0]), pubkeysAlligned,\
        c0,\
        len(ss), len(ss[0]), ssAlligned,\
        len(II), IIAlligned], gas=99999999999, gas_price=1)
    bashCommand = 'curl -X POST 127.0.0.1:8545 -m 3 --data ' + results.replace(" ", "")
    import subprocess
    process = subprocess.Popen(bashCommand.split(), stdout=subprocess.PIPE)
    output, error = process.communicate()
    print(output)
    print("ERROR: ",error)
    print("------Transaction sent, waiting events-------")
    for i in range(0, 200):
        time.sleep(1);
        if i%10== 0:
            print(i)

    for i in range(0, len(filter)):
        change = connection.eth_getFilterChanges(filter[i])
        if len(change) > 0:
            for j in range(0, len(change)):
                if filterNames[i] == "Print uint256":
                    print(filterNames[i] + " result " + str(j) + ":\n" + str(to_int_from_bytes(bytes.fromhex(change[j]["data"][2:]))))
                else:
                    print(filterNames[i] + " result " + str(j) + ":\n" + str(bytes.fromhex(change[j]["data"][2:])))

    print("------ All events have been displayed -------")


def ecdhEncode(mask, amount, receiverPk): 
    # mask: the mask to hide (32 bytes number)
    # amount: the amount to hide (32 bytes number)
    # receiverPk: the receiver pk (sec format)
    ## return: newMask: hidden mask (32 bytes number)
    ##         newAmount: hidden amount (32 bytes number)
    ##         senderPk: the public key genereated by the sender to encode this amount (sec format)

    secret = to_32_bytes_number(random.randrange(crv.order))
    senderSk= g.from_string(secret, curve=crv)
    senderPk = senderSk.verifying_key
    recvPubKey = VerifyingKey.from_string(receiverPk, curve=crv)
    to_hash = VerifyingKey.from_public_point(recvPubKey.pubkey.point * to_int_from_bytes(secret), curve=crv).to_string()
    sharedSecretInt = to_int_from_bytes(hashlib.sha256((to_hash)).digest())
    newMask = (to_int_from_bytes(mask) + sharedSecretInt) % crv.order
    newAmount = (to_int_from_bytes(amount) + sharedSecretInt) % crv.order
    return  to_32_bytes_number(newMask), to_32_bytes_number(newAmount), senderPk.to_string()

def ecdhDecode(mask, amount, senderPk, receiverSk): 
    # counter method to ecdh encode
    # mask: the hidden mask (32 bytes number)
    # amount: the hidden amount (32 bytes number)
    # senderPk: the public key genereated by the sender to encode this amount (sec format)
    # receiverSk: the receiver sk (32 bytes number)
    ## return: newMask: unhidden mask (32 bytes number)
    ##         newAmount: unhidden amount (32 bytes number)

    sendPubKey = VerifyingKey.from_string(senderPk, curve=crv)
    to_hash = VerifyingKey.from_public_point(sendPubKey.pubkey.point * to_int_from_bytes(receiverSk), curve=crv).to_string()
    sharedSecretInt = to_int_from_bytes(hashlib.sha256((to_hash)).digest())
    newMask = (to_int_from_bytes(mask) - sharedSecretInt) % crv.order
    newAmount = (to_int_from_bytes(amount) - sharedSecretInt) % crv.order
    return to_32_bytes_number(newMask), to_32_bytes_number(newAmount)

def createTransaction(message, inPk, inSk, inAmounts, destinations, outAmounts, mixin):
    # inPk: vector of public keys corresponding to the owner inputs(sec format)
    # inSk: vector of private keys corresponding to the public keys (format 32bytes number)
    # inAmounts: vector of number corresponding to the amount coming from corresponding public key
    # destinations: vector of public keys (sec format)
    # outAmounts: vector of the different amounts going to the respective destinations public keys (int)
    # mixin: the number of pk to get involved in the rings (int)
    ## return: destinations: a vector of destinations public keys as received (sec format)
    ##         destinationsCommitment: a vector of commitment assigned to each destinations public keys (32 bytes numbers)
    ##         I: part of MLSAG, a vector of pk in sec format corresponding the the sha256 hash of the sender pk 
    ##         c_0: part of MLSAG, first sha3_256 (keccak) of the consecutive series of the MLSAG 
    ##         ss: part of MLSAG, a matrix of "random" 32 bytes number
    ##         infos: an array of ecdhEncode result containing the amount paid to the corresponding output pk
    ##         rangeSig: vector of rangeSig (format TODO)

    print("------ Let's create a the transaction -------")
    assert mixin < MAX_MIXIN and mixin > 0, "The number of ring participant should be between 0 and " + str(MAX_MIXIN) + "\n Aborting..."
    assert len(inSk) == len(inPk) and len(inAmounts) == len(inPk), \
        "The number of private key doesn't match the number of public key or the number of input amounts.\n\
        Aborting..."
    assert len(destinations) == len(outAmounts), \
        "The number of outputs addresses should match the number of outputs amounts.\n\
        Aborting..."
    m = len(inSk)
    for i in range(0, m):
        assert inAmounts[i] > 0 and inAmounts[i] < MAX_AMOUNT, \
            "The ingoing amount #" + str(i) + " should be between 0 and " + str(MAX_AMOUNT) + "\n\
            Aborting..."
    outNum = len(destinations)
    for i in range (0, outNum):
        assert outAmounts[i] > 0 and outAmounts[i] < MAX_AMOUNT, \
            "The outgoing amount #" + str(i) + " should be between 0 and " + str(MAX_AMOUNT) + "\n\
            Aborting..."

    for i in range(0, m):
        assert g.from_string(inSk[i], curve=crv).verifying_key.to_string() == inPk[i], \
            "One secret key doesn't match the corresponding public key.\n\
            Aborting..."

    print("------ All arguments are good, next ! -------")

    inSkMasks = [] 
    inPkMasks = [] 
    for i in range(0, m):
        skMask = to_32_bytes_number(random.randrange(crv.order))
        inSkMasks.append(skMask)
        pkMask = g.from_string(skMask, curve=crv).verifying_key
        aH = hash_to_point(to_32_bytes_number(1)).pubkey.point * inAmounts[i]
        pkMaskPoint = pkMask.pubkey.point + aH
        inPkMasks.append(VerifyingKey.from_public_point(pkMaskPoint).to_string())

    destinationsCommitment = []
    infos = []
    rangeSig = []
    outSkMasks = []
    for i in range(0, outNum):
        print("------Creating rangeproof for amount#" + str(i+1) + "-------")
        outCommit, outSkMask, rg = proveRange(outAmounts[i])
        destinationsCommitment.append(outCommit)
        outSkMasks.append(outSkMask)
        rangeSig.append(rg)
        hiddenMask, hiddenAmount, senderPk = ecdhEncode(outSkMask, to_32_bytes_number(outAmounts[i]), destinations[i])
        infos.append([hiddenMask, hiddenAmount, senderPk])

    print("------  Rangeproofs are valid. Next   -------")

    pkMatrix, pkMasksMatrix, index = populateFromBlockchain(inPk, inPkMasks, mixin)

    print("------Matrix populated, going further!-------")

    if debug:
        (newMatrix, (L, R, I, c_0, ss)) = prepareMG(message, pkMatrix, pkMasksMatrix, inSk, inSkMasks, destinationsCommitment, outSkMasks, index)
        print("------Transaction created with succes!-------")
        return newMatrix, L, R, destinations, destinationsCommitment, I, c_0, ss, infos, rangeSig
    else:
        (newMatrix, (I, c_0, ss)) = prepareMG(message, pkMatrix, pkMasksMatrix, inSk, inSkMasks, destinationsCommitment, outSkMasks, index)
        print("------Transaction created with succes!-------")
        return newMatrix, destinations, destinationsCommitment, I, c_0, ss, infos, rangeSig

def verTransaction(message, newMatrix, destinations, destinationsCommitment, I, c_0, ss, infos, rangeSig):
    for rg in rangeSig:
        verRangeProofs(rg)
    verifyMG(message, newMatrix, I, c_0, ss)

def prepareMG(message, pubsK, pubsC, inSk, inSkMask, outC, outSkMasks, index):
    # pubsK: matrix of public key (size: qxm, sec format)
    # pubsC: matrix of commitment for pk (size: qxm, 32bytes)
    # inSk: vector of private key (size: m, bytes32 format)
    # inSkMask: vector of mask for the corresponding sk (size: m, 32bytes)
    # outC: vector of commitment for pk (hidden amount) (size: outPKsize, 32bytes)
    # outSkMasks: vector mask for out public keys (bytes32)
    # index: index of where in the pubsK matrix our pks are located
    ## returns: same a genMG

    print("------ Preparing the matrix for the MG-------")

    rowsQ = len(pubsK)
    if debug:
        assert len(pubsK) == len(pubsC) and len(pubsK) > 0, "\
            Mismatch in the number of public commitment and keys.\nAborting..."
    colsM = len(pubsK[0])
    if debug:
        assert len(inSk) == len(inSkMask) and len(inSk) == colsM, \
            "Mismatch in the number of private keys or private key masks.\nAborting..."
        for i in range(0, rowsQ): 
            assert len(pubsK[i]) == len(pubsC[i]) and len(pubsK[i]) == colsM, \
                "Mismatch in the number of public commitment and keys.\nAborting..."
        assert index >= 0 and index < rowsQ, "index: " + str(index) + " should be between 0 and "\
            + str(rowsQ) + " (the number of public key).\nAborting..."
        assert len(outC) == len(outSkMasks) and len(outC) > 0, \
            "Mismatch in the number of private commitment and keys.\nAborting..."

    matrix = [[None for x in range(colsM + 1)] for y in range(rowsQ)]
    sk = [None for x in range(colsM + 1)]
    for i in range(colsM):
        sk[i] = inSk[i]
        if i == 0:
            sk[colsM] = inSkMask[i]
        else:
            sk[colsM] = add_2_32b(sk[colsM], inSkMask[i])
        for j in range(rowsQ):
            matrix[j][i] = pubsK[j][i]
            if i == 0:
                matrix[j][colsM] = VerifyingKey.from_string(pubsC[j][i]).pubkey.point
            else:
                matrix[j][colsM] = matrix[j][colsM] + VerifyingKey.from_string(pubsC[j][i]).pubkey.point

    for i in range(len(outC)):
        sk[colsM] = sub_2_32b(sk[colsM], outSkMasks[i])
    for i in range(rowsQ):
        for j in range(len(outC)):
            point = VerifyingKey.from_string(outC[j]).pubkey.point
            matrix[i][colsM] = matrix[i][colsM] + VerifyingKey.from_public_point(Point(crv.curve, point.x(), (-point.y()) % crv.curve.p(), crv.order)).pubkey.point

    for j in range(rowsQ):
        matrix[j][colsM] = VerifyingKey.from_public_point(matrix[j][colsM]).to_string()

    print("------ Done with the matrix for the MG-------")

    #TODO message
    return (matrix, genMG(message, matrix, sk, index))



def list_to_bytes(list):
    # [[None, None] for x in range(m)]
    ret = to_32_bytes_number(list[0][0]) + to_32_bytes_number(list[0][1])
    for x in range(1, len(list)):
        ret += to_32_bytes_number(list[x][0]) + to_32_bytes_number(list[x][1])
    return ret

def genMG(message, matrix, sk, index):

    n = len(matrix)
    if debug:
        assert n > 0, "No public key received.\nAborting..."
    m = len(matrix[0])
    if debug:
        assert m == len(sk), "The number of secret key doesn't match the number of public key.\nAborting..."
        for i in range(0, n):
            assert len(matrix[i]) == m, "Public key array is not rectangular.\nAborting..."
        assert m > 0, "No public key in the array.\nAborting..."
        assert index >= 0 and index < m, "Not a valid index.\nAborting..."
        for i in range(0, m):
            assert g.from_string(sk[i], curve=crv).verifying_key.to_string() == matrix[index][i], \
                "One secret key doesn't match the public key. Index: " + str(i) + "\n\
                Aborting..."

    message_bytes = bytes(message, 'UTF-8')

    alpha = [None for x in range(m)]
    I = [None for x in range(m)]
    ss = [[None for x in range(m)] for y in range(n)]
    
    L = [[[None, None] for x in range(m)] for y in range(n)] 
    R = [[[None, None] for x in range(m)] for y in range(n)] 

    for j in range(0, m):
        skJHashPub_point = hash_to_point(matrix[index][j]).pubkey.point * to_int_from_bytes(sk[j])
        I[j] = VerifyingKey.from_public_point(skJHashPub_point, curve=crv).to_string()
 
        alpha[j] = to_32_bytes_number(random.randrange(crv.order))
        LPoint = g.from_string(alpha[j], curve=crv).verifying_key.pubkey.point
        L[index][j] = [LPoint.x(), LPoint.y()]

        alphaHashPub_point = hash_to_point_special(matrix[index][j]).pubkey.point * to_int_from_bytes(alpha[j])
        R[index][j] = [alphaHashPub_point.x(), alphaHashPub_point.y()]

    c_idx_1 = sha3.keccak_256(message_bytes + list_to_bytes(L[index]) + list_to_bytes(R[index])).digest()



    c = c_idx_1
    c_0 = None
    for i in range(1, n): 
        idx = (index + i) % n
        for j in range(0, m):
            # assert ss[idx][j] == None, "Hmm sounds bad"
            ss[idx][j] = to_32_bytes_number(random.randrange(crv.order))

            c_PubK = VerifyingKey.from_string(matrix[idx][j], curve=crv).pubkey.point * to_int_from_bytes(c)
            sj_G = g.from_string(ss[idx][j], curve=crv)
            L_point = c_PubK + sj_G.verifying_key.pubkey.point
            L[idx][j] = [L_point.x(), L_point.y()]


            c_I = VerifyingKey.from_string(I[j], curve=crv).pubkey.point * to_int_from_bytes(c)
            R_point = hash_to_point_special(matrix[idx][j]).pubkey.point * to_int_from_bytes(ss[idx][j]) + c_I
            R[idx][j] = [R_point.x(), R_point.y()]

        c = sha3.keccak_256(message_bytes + list_to_bytes(L[idx]) + list_to_bytes(R[idx])).digest();
        if idx == n-1:
            c_0 = c

    print("------ Done with generating the MLSAG -------")

    if debug:
        # sanity check:
        L_tmp = [[None, None] for x in range(m)]
        R_tmp = [[None, None] for x in range(m)]

        for j in range(0, m):
            ss[index][j] = to_32_bytes_number((to_int_from_bytes(alpha[j]) - to_int_from_bytes(c) * to_int_from_bytes(sk[j])) % crv.order)

            c_PubK = VerifyingKey.from_string(matrix[index][j], curve=crv).pubkey.point * to_int_from_bytes(c)
            sj_G = g.from_string(ss[index][j], curve=crv)
            L_point = c_PubK + sj_G.verifying_key.pubkey.point
            L_tmp[j] = [L_point.x(), L_point.y()]

            c_I = VerifyingKey.from_string(I[j], curve=crv).pubkey.point * to_int_from_bytes(c)
            R_point = hash_to_point_special(matrix[index][j]).pubkey.point * to_int_from_bytes(ss[index][j]) + c_I
            R_tmp[j] = [R_point.x(), R_point.y()]

        c_tmp = sha3.keccak_256(message_bytes + list_to_bytes(L_tmp) + list_to_bytes(R_tmp)).digest()
        assert L_tmp == L[index] and R_tmp == R[index], "Sanity check for computing ss[index] failed.\nAborting..."

    if debug:
        assert verifyMG(message, matrix, I, c_0, ss), "Ring verification failed.\nAborting..."
        print("--------- Done with verifying the MLSAG  -------")
        return L, R, I, c_0, ss
    else:
        return I, c_0, ss

def verifyMG(message, matrix, I, c_0, ss):
    n = len(ss)
    assert n > 0, "No ss in the ring signature. Length = 0."
    assert len(matrix) == n, "Mismatch"
    m = len(ss[0])
    for i in range(0, n):
        assert len(ss[i]) == m, "Non rectangular ss in the ring signature."
    assert m > 0, "No ss in the ring siganture. Length ss[0] = 0"
    assert len(I) == len(ss[0]), "Not the same number of pubkey hash (I) as of secret (ss)."

    message_bytes = bytes(message, 'UTF-8')

    L = [[[None, None] for x in range(m)] for y in range(n)] 
    R = [[[None, None] for x in range(m)] for y in range(n)] 

    c = c_0
    for idx in range(0, n): 
        for j in range(0, m):
            print("----- " + str(idx * m + j) + "")
            c_PubK = VerifyingKey.from_string(matrix[idx][j], curve=crv).pubkey.point * to_int_from_bytes(c)
            sj_G = g.from_string(ss[idx][j], curve=crv)
            L_point = c_PubK + sj_G.verifying_key.pubkey.point
            L[idx][j] = [L_point.x(), L_point.y()]
            print(sj_G.verifying_key.pubkey.point.x())
            print(sj_G.verifying_key.pubkey.point.y())
            print("^^^^^^^")
            print(c_PubK.x())
            print(c_PubK.y())
            print("++++++")
            
            c_I = VerifyingKey.from_string(I[j], curve=crv).pubkey.point * to_int_from_bytes(c)
            p = hash_to_point_special(matrix[idx][j]).pubkey.point * to_int_from_bytes(ss[idx][j])
            # opo = VerifyingKey.from_string(matrix[idx][j]).pubkey.point
            # print(opo.x())
            # print(opo.y())
            # opo2 = hashlib.sha256(to_32_bytes_number(opo.x())+to_32_bytes_number(opo.y())).digest()
            # print(int.from_bytes(opo2, 'big'))
            # print(g.from_string(opo2).verifying_key.pubkey.point.x())
            # print(g.from_string(opo2).verifying_key.pubkey.point.y())
            # print("^^^^^^^")
            # print(g.from_secret_exponent(int.from_bytes(opo2, 'big')).verifying_key.pubkey.point.x())
            # print(g.from_secret_exponent(int.from_bytes(opo2, 'big')).verifying_key.pubkey.point.y())
            # print("++++++")
            print(str(p.x()))
            print(str(p.y()))
            print("......")
            print(str(c_I.x()))
            print(str(c_I.y()))
            print("******")
            R_point = p + c_I
            R[idx][j] = [R_point.x(), R_point.y()]

        print(L[idx])
        print(R[idx])

        c = sha3.keccak_256(message_bytes + list_to_bytes(L[idx]) + list_to_bytes(R[idx])).digest();
        print("CCCCCCCC = ", end="")
        print(str(int.from_bytes(c, 'big')))

    return c == c_0

def populateFromBlockchain(publicKey, inPkMasks, mixin):
    # publicKey: vector of pk, sec format
    # inPkMasks: vector of bytes32 (format from verifyingkey.to_string())
    # mixin: number of other pk involved, int
    ## return: pk matrix (format sec), 
    ##         coressponding masks matrix, 
    ##         index of our pks in the matrix

    if debug:
        assert len(publicKey) == len(inPkMasks), \
            "Mismatch in the number of public key and their corresponding mask\n\
            Aborting..."
    m = len(publicKey)
    index = random.randrange(mixin - 1)
    pkMatrix = []
    maskMatrix = []
    for i in range(0, mixin):
        if i != index:
            pkMatrix.append([getKeyFromBlockchain() for i in range(0, m)])
            maskMatrix.append([hash_to_point(to_32_bytes_number(random.randrange(crv.order))).to_string() for i in range(0, m)])
        else: 
            pkMatrix.append(publicKey)
            maskMatrix.append(inPkMasks)
    return pkMatrix, maskMatrix, index

def getKeyFromBlockchain():
    #TODO
    ## return: a public key "from the blockchain" in the to_string format
    x = to_32_bytes_number(random.randrange(crv.order))
    return g.from_string(x).verifying_key.to_string()

def GenSchnorrNonLinkable(x, P1, P2, index):
    # x: bytes32 number
    # P1: pubkey in to string format bytes32
    # P2: pubkey in to string format bytes32

    if index == 0:
        a = to_32_bytes_number(random.randrange(crv.order))
        L1Point = g.from_string(a).verifying_key.pubkey.point
        s2 = to_32_bytes_number(random.randrange(crv.order))
        c2 = hashlib.sha256(to_32_bytes_number(L1Point.x()) + to_32_bytes_number(L1Point.y())).digest()
        L2Point = g.from_string(s2).verifying_key.pubkey.point + (VerifyingKey.from_string(P2).pubkey.point * to_int_from_bytes(c2))
        c1 = hashlib.sha256(to_32_bytes_number(L2Point.x()) + to_32_bytes_number(L2Point.y())).digest()
        s1 = to_32_bytes_number((to_int_from_bytes(a) -  to_int_from_bytes(x) * to_int_from_bytes(c1)) % crv.order)

        # sanity check
        if(debug):
            L1p = g.from_string(s1).verifying_key.pubkey.point + (VerifyingKey.from_string(P1).pubkey.point * to_int_from_bytes(c1))
            assert VerifyingKey.from_public_point(L1p).to_string() == VerifyingKey.from_public_point(L1Point).to_string(), \
                "Sanity check failed in GenSchnorr 1\nAborting..."
    if index == 1:
        a = to_32_bytes_number(random.randrange(crv.order))
        L2Point = g.from_string(a).verifying_key.pubkey.point
        s1 = to_32_bytes_number(random.randrange(crv.order))
        c1 = hashlib.sha256(to_32_bytes_number(L2Point.x()) + to_32_bytes_number(L2Point.y())).digest()
        L1Point = g.from_string(s1).verifying_key.pubkey.point + (VerifyingKey.from_string(P1).pubkey.point * to_int_from_bytes(c1))
        c2 = hashlib.sha256(to_32_bytes_number(L1Point.x()) + to_32_bytes_number(L1Point.y())).digest()
        s2 = to_32_bytes_number((to_int_from_bytes(a) - (to_int_from_bytes(x) * to_int_from_bytes(c2))) % crv.order)
        # sanity check
        if(debug):
            L2p = g.from_string(s2).verifying_key.pubkey.point + (VerifyingKey.from_string(P2).pubkey.point * to_int_from_bytes(c2))
            assert VerifyingKey.from_public_point(L2p).to_string() == VerifyingKey.from_public_point(L2Point).to_string(), \
                "Sanity check failed in GenSchnorr 2\nAborting..."
    L1 = VerifyingKey.from_public_point(L1Point).to_string()
    return L1, s1, s2

def VerSchnorrNonLinkable(P1, P2, L1, s1, s2):
    # P1: Pubkey in from_string format (32 bytes)
    # P2: Pubkey in from_string format (32 bytes)
    # L1: output of GenSchnorr, pubkey in from_string format (32 bytes)
    # s1: output of GenSchnorr, number (32 bytes)
    # s2: output of GenSchnorr, number (32 bytes)
    L1Point = VerifyingKey.from_string(L1).pubkey.point
    c2 = hashlib.sha256(to_32_bytes_number(L1Point.x()) + to_32_bytes_number(L1Point.y())).digest()
    L2PointA = g.from_string(s2).verifying_key.pubkey.point
    L2Point = g.from_string(s2).verifying_key.pubkey.point + (VerifyingKey.from_string(P2).pubkey.point * to_int_from_bytes(c2))
    c1 = hashlib.sha256(to_32_bytes_number(L2Point.x()) + to_32_bytes_number(L2Point.y())).digest()
    L1p = VerifyingKey.from_public_point(g.from_string(s1).verifying_key.pubkey.point + (VerifyingKey.from_string(P1).pubkey.point * to_int_from_bytes(c1))).to_string()
    assert L1 == L1p, "GenSchnorrNonLinkable failed to generate a valid signature.\nAborting..."

def GenASNL(x, P1, P2, indices):
    # x: vector of 32bytes number serving as mask
    # P1: Public key 1, from_string format (32bytes)
    # P2: Public key 2, from_string format (32bytes)
    # indices: vector of number (1 and 0 in our case) to specify which public key will be used to close the ring
    ## returns: L1: vector of public key (to_string format, 32bytes)
    ##          s2: vector of 32 bytes number
    ##          s: 32 bytes number, aggregate of s1
    n = len(x)
    L1 = [None] * n
    s1 = [None] * n
    s2 = [None] * n
    s = to_32_bytes_number(0)
    print("Generating the per bit signature of the amount")
    for j in range(0, n):
        if j % (n//10) == 0:
            print("[", end='')
            for u in range(0, 10):
                if u < (j*10)/n:
                    print("#", end='')
                else:
                    print(" ", end='')
            print("]")
        L1[j], s1[j], s2[j] = GenSchnorrNonLinkable(x[j], P1[j], P2[j], indices[j])
        if debug:
            VerSchnorrNonLinkable(P1[j], P2[j], L1[j], s1[j], s2[j])
        s = add_2_32b(s, s1[j])
    return L1, s2, s

def VerASNL(P1, P2, L1, s2, s):
    # P1: Public key 1, from_string format (32bytes)
    # P2: Public key 2, from_string format (32bytes)
    # L1: vector of public key (to_string format, 32bytes)
    # s2: vector of 32 bytes number
    # s: 32 bytes number, aggregate of s1
    n = len(P1)
    LHS = to_32_bytes_number(0)
    RHS = g.from_string(s).verifying_key.pubkey.point
    # print(RHS.x())
    for j in range(0, n):
        c2 = hashlib.sha256(L1[j]).digest()
        # print(to_int_from_bytes(c2))
        L2Point = g.from_string(s2[j]).verifying_key.pubkey.point + (VerifyingKey.from_string(P2[j]).pubkey.point * to_int_from_bytes(c2))
        # print(L2Point.x())
        L2 = VerifyingKey.from_public_point(L2Point).to_string()
        if j == 0:
            LHS = VerifyingKey.from_string(L1[j]).pubkey.point
        else:
            LHS = LHS + VerifyingKey.from_string(L1[j]).pubkey.point
        c1 = hashlib.sha256(L2).digest()
        # print(to_int_from_bytes(c1))
        RHS = RHS + (VerifyingKey.from_string(P1[j]).pubkey.point * to_int_from_bytes(c1))
    assert VerifyingKey.from_public_point(LHS).to_string() == VerifyingKey.from_public_point(RHS).to_string(), \
        "GenASNL failed to generate a valid signature.\nAborting..."
    # print(LHS.x())
    # print(RHS.x())
    # print(LHS.y())
    # print(RHS.y())

def proveRange(amount):
    # amount: the amount to prove range from, in int
    ## returns: C_pk: output commitment serving as a public key (to_string 32bytes format)
    ##          mask: part of the private key for C_pk. mask * G + amount * H == C_pk, 32 bytes number format
    ##          rg: vector of range proofs, each entry contain a vector of public key Ci and a aggregate signature.
    ##              The aggregate signature itself contains L1: vector of public key (to_string format, 32bytes)
    ##                                                      s2: vector of 32 bytes number
    ##                                                      s: 32 bytes number, aggregate of s1
    ##              For more infos on asig, see GenASNL(...)

    HPow2 = hash_to_point(to_32_bytes_number(1)).pubkey.point
    H2 = []
    for i in range(0, ATOMS):
        H2.append(VerifyingKey.from_public_point(HPow2).to_string())
        HPow2 = HPow2 * 2

    def d2b(n, digits):
        b = [0] * digits
        i = 0
        while n:
            b[i] = n & 1
            i = i + 1
            n >>= 1
        return b 

    bb = d2b(amount, ATOMS) #gives binary form of bb in "digits" binary digits
    mask = to_32_bytes_number(0)
    
    C = to_32_bytes_number(0)
    ai = []
    Ci = []
    CiH = []

    print("------  Preparing different elements  -------")
    for i in range(0, ATOMS):
        ai.append(to_32_bytes_number(random.randrange(crv.order)))
        mask = add_2_32b(mask, ai[i]) #creating the total mask since you have to pass this to receiver...
        if bb[i] == 0:
            Ci.append(g.from_string(ai[i]).verifying_key.to_string())
        if bb[i] == 1:
            Ci.append(VerifyingKey.from_public_point(\
                g.from_string(ai[i]).verifying_key.pubkey.point + \
                VerifyingKey.from_string(H2[i]).pubkey.point\
                ).to_string())


        negateH2 = Point(crv.curve, VerifyingKey.from_string(H2[i]).pubkey.point.x(), (-VerifyingKey.from_string(H2[i]).pubkey.point.y()) , crv.order)
        CiH.append(VerifyingKey.from_public_point(VerifyingKey.from_string(Ci[i]).pubkey.point + negateH2).to_string()) 
        
        if debug and bb[i] == 1:
            #Sanity check A + h2 - h2 == A
            assert g.from_string(ai[i]).verifying_key.to_string() == CiH[i], \
                "Sanity check failed in proveRange !" + bytes.hex(g.from_string(ai[i]).verifying_key.to_string()) +\
                " ---- " + bytes.hex(CiH[i])
    if rangSigBool == True:
        L1, s2, s = GenASNL(ai, Ci, CiH, bb)
        if debug:
            VerASNL(Ci, CiH, L1, s2, s)

        asig = [L1, s2, s]
        rg = [Ci, asig]
    else:
        rg = 1

    C_point = VerifyingKey.from_string(Ci[0]).pubkey.point
    for i in range(1, len(Ci)):
        C_point = C_point + VerifyingKey.from_string(Ci[i]).pubkey.point

    C = to_32_bytes_number(0)
    for i in range(0, len(Ci)):
        C = add_2_32b(C, Ci[i])


    C_pk = VerifyingKey.from_public_point(C_point)
    if debug:
        x = hash_to_point(to_32_bytes_number(1)).pubkey.point * amount + g.from_string(mask).verifying_key.pubkey.point
        assert C_pk.to_string() == VerifyingKey.from_public_point(x).to_string(), \
            "Something went wrong in the genreation of the commitment! " +\
            bytes.hex(C_pk.to_string()) + " should equal " + bytes.hex(VerifyingKey.from_public_point(x).to_string())

    return C_pk.to_string(), mask, rg


def verRangeProofs(rg):
    HPow2 = hash_to_point(to_32_bytes_number(1)).pubkey.point
    H2 = []
    for i in range(0, ATOMS):
        H2.append(VerifyingKey.from_public_point(HPow2).to_string())
        HPow2 = HPow2 * 2
    CiH = []
    Ci = rg[0]
    [L1, s2, s] = rg[1]
    for i in range(0, ATOMS):
        negateH2 = Point(crv.curve, VerifyingKey.from_string(H2[i]).pubkey.point.x(), (-VerifyingKey.from_string(H2[i]).pubkey.point.y()) , crv.order)
        CiH.append(VerifyingKey.from_public_point(VerifyingKey.from_string(Ci[i]).pubkey.point + negateH2).to_string()) 
    VerASNL(Ci, CiH, L1, s2, s)


def test():
    print("------  Entering the first test case. -------")

    for i in range(0, 10):
        x = random.randrange(2**256)
        assert x == to_int_from_bytes(to_32_bytes_number(x)), "bytes <-> int conversion failed, x = %d" % (x)
    
    print("------ Entering the second test case. -------")

    for i in range(0, 10):
        x = random.randrange(crv.order)
        y = random.randrange(crv.order)
        newMask, newAmount, sendPubKey = ecdhEncode(to_32_bytes_number(x), to_32_bytes_number(y), bytes.fromhex(pub))
        newX, newY = ecdhDecode(newMask, newAmount, sendPubKey, bytes.fromhex(pri))
        assert to_int_from_bytes(newX) == x and to_int_from_bytes(newY) == y, "ECDH failed, x = %d, y = %d" % (x, y)

    print("------  All test passed. Well done !  -------")



with open("contractAddress.txt") as f:
    content = f.readlines()
# you may also want to remove whitespace characters like `\n` at the end of each line
content = [x.strip() for x in content]
found = False
i = 0
while not found and i < len(content):
    if content[i][0:7] == 'RingCT:':
        found = True
        contractAddress = content[i][8:50]
    i += 1
if not found:
    import sys
    sys.exit("Error message")
upu = 0
pri = "07ca500a843616b48db3618aea3e9e1174dede9b4e94b95b2170182f632ad47c"
pri4 = "79d3372ffd4278affd69313355d38c6d90d489e4ab0bbbef9589d7cc9559ab6d"
pri5 = "00dff8928e99bda9bb83a377e09c8bf5d110c414fa65d771b7b84797709c7dd0b1"
pub = "0462abcca39e6dbe30ade7be2949239311162792bdb257f408ccd9eab65e18bc5bbcf8a3f08675bd792251a23d09a48a870644ba3923996cc5b5ec2d68043f3df3"
pub2 = "040ccad48919d8f6a206a1ac7113c22db62aa744a0700762b70aa0284d474c00203029637ce8e84f6551fd92a0db8e1f964ff13aa992e4cbfd1fb8fa33c6e6c53c"
pub3 = "049f742f925b554e2dc02e2da5cb9663ef810e9eefb30818b3c12bc26afb8dd7ba3461c0f7d2b997bf455973af308a71ed34ae415cfc946de84db3961db522e5d2"
pub4 = "04ef36c6d140e7970cc54c08e0e5d3173059ee6276dd0de99e09d10c49bd49e63c44e0a2e7180fff5e3e8a549027b8a37bc3a9437374ef1b7a05040b244a7bccc5"
pub5 = "04da11a42320ae495014dd9c1c51d43d6c55ca51b7fe9ae3e1258e927e97f48be4e7a4474c067154fdaa1c5b26dee555c3e649337605510cf9e1d5c1e657352e9c"
# createTransaction(bytes.fromhex(pri), bytes.fromhex(pub), [bytes.fromhex(pub2), bytes.fromhex(pub3)], [1, 2], 2)





# helloashjdagfghfhgjhjgjdlas = []
inAmounts = [3,4]
inSk = []
inPk = []
for i in range(0, len(inAmounts)):
    sk = to_32_bytes_number(random.randrange(crv.order))
    inSk.append(sk)
    inPk.append(g.from_string(sk, curve=crv).verifying_key.to_string())

outAmount = [1, 6]
message = "hello"
outputPub = [VerifyingKey.from_sec(bytes.fromhex(pub)).to_string(), VerifyingKey.from_sec(bytes.fromhex(pub5)).to_string()]
matrix, L, R, destinations, destinationsCommitment, I, c, ss, infos, rangeSig =  createTransaction(message, inPk, inSk, inAmounts, outputPub, outAmount, 2)
verTransaction(message, matrix, destinations, destinationsCommitment, I, c, ss, infos, rangeSig)
# upu = 1;

# print("I = ", end='')
# print(I)
# print("c = ", end='')
# print(c)
# print("ss = ", end='')
# print(ss)
# print("matrix = ", end='')
# print(matrix)
# print("L = ", end='')
# print(L)
# print("R = ", end='')
# print(R)

# if(upu == 0):
#     I = [b'q\xc0\x8bc2\x80\x80\xfb\xb7r2 \xf46\x0f\xbb\xed\x0e\xd6,\xe3\xd9S\x8e\xe7\xed@\xcc\x81\x0c8\x1c\xfd\xf2va3TR\x90m\x9c\n\n\xd8\x12\xd9,\xbc\xf5\x11\xef7ipg\xe8N0Y\x8ee\xdf%', b"\x8a\x85\xacWF_RG'2\x9bz\xf5\x15w\x01R\xf0Q(u\xbf\x18d\xc6\x04\x90\x91\n\xdf\x9c\x0b\x91\x02\x07\xc1\xfc\xb6\xc0D^S\x1b\xf0Q\xa3\x19Li\x9a\xed\x10\\\xdd\x9d\xac\xabqj\x13-4C\xfb", b'\x99y\xc9m\xefX\x1d\xebK\x1f\x0e`\x11d\xaaN\x9d*u\x87\x05}\x02\xc8\xcc@\x96\xfc\xbd\xa9v5l^\xb6(\x1a\x9f\xf7\xde\x84\x98\xfdyp\x0c\x9a\xb6\xdb1\xc6\x0c\x03@,\x0e\xb9k\xdaS\xc7\xb6\xff\xa9']
#     c = b"'\xf5V\xc5\xf2\x82)\x0f\x05\x9eA\xa2\x0f\xb9\x81\xe0\\\x12\xd4{\x15E\x8e\xfc\x12\xcb\x8ee)\x08\xabM"
#     ss = [[b'\xf4\xb1\xb9\x01\xe5\xe2lM\x0f\x8d\xf0\xbf\x7f\xdfy\xa8\xb0_\x0b\xe0\x0f\xf94\x16E\xf2V\xf2\xce\xd4[_', b'\xeag\xd84\xa3mg\xae\n\xdb2\xbc\xd3\xd8\xe4\xe9~W\x98\x1b\xe5\xa7\x96\x17\x0c\xb9\x1d\xc3\x85\xa7\x85\xb3', b',!\xdf\xf6\xa5\x92\x0e\x92\xeb]b{\xc4E\x80tA\xea\x0b\xd4\xfb9Y\xa1\x91{}\x01\x01\xd2\\\xe8'], [b'\x96:\xaa\xa1\xfd\xbaGb?\xa1@n^n~\xaadk\xd0L\xb0^GG\\\x01\x89\xfaq\xc8<u', b'\xf4\x0c\xd3\x1b,\xdf\n\x8cb}\xe5\x1cE\xe4\x00\xc4\xbc\xd1s\xc6\x89\x080%\x15x8`\xc6\x1an,', b'E\xbax\xba\xf9\x94\xff\r\xe3v\xa2i\x93\x05n\xdbv2\x9bd\x1a6\xcc\xaf\xc4\x1e\x8f,\xca\x07\x01\x1e']]
#     matrix = [[b'\x91%\xe8\xaf\xb0i\xfbh\xee9\x89&\x82\xa2\x0f\x15*\x92\x07\x9e\xf1\xc3\x84\xa5\xaa\xb6\xff_\x0c?a<j.?\x10x:F\xd8E\xd9\xad\x08t\x07\x8e|\x19\xf3\x87\xa7\x89\xe9\xaf~_\x00_b%;\x93\xd3', b"R\xa0\xc9_Z\x13\xbe\xb5\xe3r\xe4\xb7\na&\x9aQ\x8e>;A\x8b\xf3jg{\xf9Gg('\xdcf?\xbeY\x8e\xd7)\xd2W\xc4\x1bZI3-7\x9d\x1a\x19\xc6$>\xc8\xb5\xc0\x03F\x95\xef`y:", b'\x1a\x0f=\xc1\xa2\x90\xdb\n\xec\x1fVg5\xaf\xcf\xd9\xadTr\xdd\x03Z\x88-h\x12D\x06\xd6L\xfd@\x97\x15\xf3\x84uB\xd8\x18\xd1\xde\x18Z\x03\x9c\xf8+\xc2\x95\xb8OQc\x03>\xf0\xd6\xca/\x95\xd1b\xc0'], [b'\xd0\xa3\x91f\x80\xb6\x1dq\x1e\xefm\xbf\x08\x9f\xd6\xf0\xae\x86\xb7\xd8\xcc\xcd\xb4\x19\xd2\x82\xa4B\x9d\x8e\xe5\xd9\xe96H\x8b\r\x1d\xbeG\x14L0\xe4\x96\xf5\xef\xa1\xea\x89\xb5\xc3\x17\x84\xf7\xa9\x9fL\xe9\xfd?\xcc\xa4\x8d', b"~\xc0\x1d\xcdS+_\r\xec\xb6Ew\xac\n\xae;kyf\xcd\x00r\x11Mv \xc1`\xf5\x05f\x84\xb5\xf2)\xd8\x89~\xe7\x89\x8a\rIb\x15\x14#\x886e>\x03\x9d\xc6Y'\xaf\xb9\x96\x15\xcc\xaa\xeda", b'\x84\x90\x1f\xf9\x83\xdf\xdd\xc6\x91VE\x99\xe4[w\xe4\x04\x03,g@\xbb>F\xfb}\xf8\x9d\xff5&\xb3\x10.B\xb0\xe2\xde\x85\xbf\xe6R\xcb5\x99-\\\xe14\x92]l\x10\xf8\xe8\xfaB\xcf0\x84\x11\xe8\xf8N']]
#     L = [[[67568219278872063116858731286494094426526800021979047794231976327118747170869, 4124190802190768737775677903319986613278382390222016340637316022983215513951], [46641593214569842105539997646855453721704848548863602426668361867957162535410, 83491591937706361677055271494614659440509889704610681787481198916046399631745], [14173759417892718798002834245712052388429749841269886368695202810622651152182, 31373863148647571773452438583396577846309280139036828349113307581326624191833]], [[78801145352555159339513583962704496235407556387744775751375136652795140956258, 101092838777187931716179914931287066081957677419110531383717730505680516974757], [111448400435557596065604471457935035895276183210779941806004156927440360105758, 21255117225304034008510093823957577381882000064380536491866085372943723083579], [59361044430883609720657060515938544433618933260609749420965371432909223799009, 41554280199625242679513783979921334403875139778410686312899620239877156442268]]]
#     R = [[[88166592521677660875561116612873821404620222753600492098689398187623435611129, 34949305312588355594419135378409933446493941130282977849679070377922577585333], [79378051287249561629292263540481953767796307454786187664433011406507282425540, 49821777734207903760215127861024368170082158648811869920196480226167766133973], [38148449668158749289165377848720927370910678745245024081894245399513925718061, 74342531632521422242417623596467069192469074355442350577403624877306094188903]], [[5905088600175110656211302465017808401270270836803172573975504241952061909806, 57276724663561780559826149283786925648514763815542425453754812051511526033383], [30394712966506654142445613665813849351445412212753691625890997522176565299714, 66992915390068631033660621189564147531739819295224793360169282471566346754438], [101827451213677863453391062100079656748656651418103194190418965897085850185119, 14909169240030856436378977082027046791714731199379557039640355049357007351253]]]
# send_ring(message, matrix, c, ss, I)


# P1 = b"\xaddEd'\x9f\xef\xe1?&J\xc3\xb3CpT\x99\xeey\xd6\xfc\xf5\xb9\xcd\x0f,/\x06g\xe4\xa9\x83\xde\xca?X/\xab\x17\x16\xaco0S\xbe\xad<Hu\x00f8\x19\xcd\x00\xfd\x82O;Ic\xe0\x1e\x90"
# P2 = b"\xd2n\x1c4n\x14\xc6\xd2i\x9c\xa1\x08\xf0\x04'G\xfd\x9b$\xc5\xf5\xf6\xf4\xe9\x94D\x99*o\x89P\x98\xc4\xd3Y\xd6E\xc8\x04\x9f\xc3\xde\x1d\x81\x82\xcd\x8f\x03)\x14\x1f\r\x08d\xfco\x83si7g;\xe1\xb4"
# L1 = b"i\x90N\xc5\x1aYO*.F\xb71\x92V\xffCvT\x98\xb6C\xfaa#g\x14[\x13[\xab\x83\x99\xe6\x91{ \xee\xc8\\\xb4\xfd\x84}\xedG\x02\x126\xa0\x10\xb6\x11'|\xdf\xe3\xec\xbcw\xc26\xa3\x99\xee"
# s1 = b'b\xdf0\xbe,\x1d\xdaj\x19Q\xa2\xdf\xee\xf6\x95\x0e\x80\xdc\xa2\xf8o\xe3$\xb89\x96j\xaf\xfa>\xce\xe6'
# s2 = b'\x99ti\x8eO\xf1\xd6V\xcb\x1b6\xfe\x81\x97\r\xd9\xa3\x0ea\xc5t\x1d\x1ca[k\x8fD\x1a\x7f\x97;'
# VerSchnorrNonLinkable(P1, P2, L1, s1, s2)


# P1 = [b'\xadX\xc5\x19\x9ev\x0f\xe1_9\x91\xb2\x19F\x04}qYB\xfa\xbd\xbc)\xd5\xb6\x9e\xb3\xablC\xc8C\xfd\xdf\xb2\x8faW\xbarzN\x0f$\x83\x1b\xed\xc6Fw\xfd\x0cZ\x13\xb7CD\xc5rIxt\xa4d', b'\x92\x11\x8e\xeb\x10t\x17\r"e\xfa\xe8\x89\x9ct;\x06}q\xf7\x82\xa8\xfd\x8as9\xf8\x15\x8b\x02\x9f\x93\xa8\x04\xed\xd1H+I\xfc\xd1\x99\x12p\x85\xa4\xe0\xfa\x9c\xe6\xc8y\xf2\xa6\xb2\x11\x15\xff\x9d\x1b\xd2\xd3{\x86', b's\xcb\x85\xcd]\x1c\xdf\xc4\xeb\xb5\\J\xdc6\x15\xac\xff\xd7"l\xba\xa3e\xfdL\x05\xad\x19\xde=*\xce\xf9pMA\xf3\x0c\xe2\xe0\x93\xd4\xb4\xc0\x13$\xc1\xd2\xedTGC\xc9\xe6\xdf.\x01\xf3\xe3\xcb\xc1\x8b\x84O', b'\xbfX\x9c\xd5\x06\xe8\xdeO\xab\x1f\xd4\xbf\x8f \xba\xa4\xcca\x98h\xdf\xd9\xa3\xa3M&\xeb|\x91\x8e_\x01\xdc*\x99\xed\xf6\xb6\xa1\xfb=Q\xf4\x0f\x06\x17\xdb\x1f-\xe0)6m\xcf\xb4J\xbe\xc7\x86X\xa0JR\xed', b'\x8a\x08OS\xb2\r\xc3\x8dF\x12*\nA\xc5\xbd\xc7#LGI\x84\x82\xd8\xa8/\x9eS\xec\xbd\xa5d\xf9\xd0\xf1yi\xf2\r\xc0\x9c\x1b&\x16\x92\xd46\xae\xe7\xa8\t\x02z\xbd\x96vm\xf8/j\x9c\xe3\xbc\xff\xf1', b'\x1ed2\xf3.(\xb7\xf9@m\xb6\x0e3v\xb1\x81\xb8%\x8eR\xed\x1d\x8a\xcc\x932"T"\x17z\xda\n\x8c^\xd8\x19\x81I\xd8\x1d\xcf\xa1\xe6\xb1#SuY\xa0.\xcd\xc4\r\x1b$N\xf8SjAo\xbd\xe9', b'\x8f!Z\x80\x89\xf6\xfa\x93t\xed\x90\xa2\xbc\xbd\xc6\x86\x1a\xf2\x00\x7fg&\x04\x1c"\xb0\x0e\xd3\\\x1e}\xb7b\xc8\x94j_%g\xa5\xcb\xd0l\n4 LV\xb0\xf7!\xde\xc3\x1b\x95o=]7\t\xd7\x87\r\xbf', b'!\xf9\x80\xffa\xac\xa6\xf6\xe2h\xe4\xf6E2\xccE^\xc8\xa3\x1b\xeb\\\x19\x13\x1e\xf7T\xc3d\xd6\xd8F\x18y)\xa9\x91eh\xb8\x99\xcby\x0b\xa92\xb4\xaa\xee\xfc\xc6\x8d$\xe6Z\x11$\xd2\x02\xfex\x84\xa0\xf0', b'rM\xd8$\x02v\xe5\x18\x93\xa3\x1f<>\x0c0Tt\x114\xcb\x0f\xf8L\x839\x08M\xf3K\xeb\xc3\x06f%\xa0$\x12X1&\xac\xaa\xf9f\xc4W#\x95\r\xc0\xf9\xe3s/b*\xbe\x8fT\x8aZ\xec\x038', b'\xa5\xe4\xf2M1\xa3\xe9\xb3P\xa5*\xc9\x93s5S\x89\xde\xc04\xb8Y\xaeFTZ\xb93\x10\x15\xae\xec\xa7\x01\xe6\x8d\x04\xeb\xbf\xf3\x03|}\x12\xdf\xf6\xeb\x95\xa7S\xe9\xf0k\xed\t\x0f\xc2\xd9\\\x8f\xadO\xd7\xdc', b"\x8a\x9f\x032\xe4$\xb1U\xefnx=\xf2\t\xba+\xa2\xdd\xb2'\xfe\xb4h*6\x19(\xad\xb8J\x143\xc6NR\xb7G\x82\x0c\x01\x0f\x05\xcfi`\xbfTU\n\xbcD?\xa3]\xd7\xc1\xa2`_lp\xab5\x9a", b'3\xf6\xf6\xec7$3\xa8It\xb0\xd3R\x07c\x83X\xf4\x8e\xf9<6b\xad\xe3\x90\xdf\x8b:,Z\xe2\xb7k\x07\x10K\x07\xca\x98rfvy\xbe\x00\t\x1eF\xb9\xa7{C,\xb0\x8c\x8dp9#\x9d#O/', b'\\\xc0\x0c\xb4\xfc0>\xc8\x96\xfb\x9a\xd5d\xe2p\x08+:=\xaa\x10\x94L\x00k\xdd\xf63Xn\xc6\xd9\x9aC\xb5\\&\x12\xca\x95j.p\x80\\2@\xd2\xcdY\\:[\x94\xe0\x19\xabEi7\x14\xb7\xf0\xaa', b'\x7f\x98\x87\xbe\xe2[%\x8e\x11\xa1I\xae\x17\x06\x92\xff\xd4\x01\xe9\x8f\x99#\xab9\xa9(\x0b\x8f\xad\x1dEG\r\xf1!\x1eJd\x8b\x0f\xfc\xc2P\x99(\x03<=P?a\xa7\xbeo\x1d\x86\xcf\xc4y\xe5\xf9\xf3\n\x0f', b')}O5\x8b\xc0\xa4>~\t\x95\xb4\xf3\x9c\x80\xe6\xbf\x8e\xacyER\xb4\x03V\xdd\x14\x19z\xc4\xf8\x82\xaf\xa4z vU\xa4\x84\xf2\x8d\xd7\x91\r\xf7v\x16\xa5[\xff\xd1o \xca\x91k\x90\xd7=j\x84\xfa\x12', b'\xad>\x87n\xf1\x04\x17\xb0\x89\xa6\x17\x02\xc9j\xc6\xffg\xcba)?\xfe\x9fryP\x82x\xf8A\x99\x86,\x05>Sy\xf8\xfc\xfa!z\x16\xe5\xc7m\x99\xdf>U\xd0-\xe7\xd3\xd1,\xf9\xe6@\xdfI\xc2\xde]', b'\xaeO\xb6\x17,\xfa\x80n\x01\xaf\x96\xe3\xafN\xa6_HCs<*\xbb\xa0\x0cj\x82\x9f\xdb\xdcr\x1c\x06\x8a:<\x15\x96\rF\xd50i\x8dV\xe1\x0e%&\xaaV\xbf\xa32\t\x1a\xc78\xae\x91M\xdc\\W?', b'\x8a\x17\xef\xf5\x9e\xb6z\x96\xc3\x87\xfc\x1f\xd6\x12>\x0f\x05\x8a\xe3\xa3\xeco\xe1TUs\xaa\xc7B\xf8\xd8l\xcb\x198\xd89\r\x8a\x91\x1e\xe0$\xae\xea\xacG\xa6\x9a\x14S\x0ff\xef\xc8\x90\x140\xfb\xb2\xd9\x8f)\xdc', b'\xa0M\xfd\x00\x1e\x8b\xa6\\\\+\x12x\xe3\xdf\xbf\xa5Bs\xc8\x92\xfe)5\x8eF\x06\x08[\xc0\xbb8g\xf8e\\\x03\xa7\xdat\xfe\xcf\xb9\xb2\x0b\x08\x00#\x8e\xf5J\x1e\xbc;3_\x05\xeaW.\x165)\xdc\x0e', b'\x80\x97Ya\xc4\xdf"T\x8f\xeb\x01\xebV\x01Xb\x03H\x8d\x9a\x96\xd9m\xe8\x8d\x02Y\x10\x15\x08\xc6\x02\xd7\x82`\x1c\x04\x80\xa4LeD\x8aR\xe9Dd\xb8py\x90\xff\xbdY\x14\xf4k\xa4,\x8a\xa8~?W', b'M2\xfb\x7f\x17\xebt\xd0\xa2\xdec\xf3\xab\x99K\xa2g\xadn\xabcRSH\xef\xcc\xce\xcb\xa7\xd7\xe8\xc3Sa\x83V\xdb\xf0O\xac\xc4\xd6\xdeE\xfa\xc6H\xba7<\xc2\xa0 ]a\xaeuQ\x7f\x98{\x97\xa4y', b"h\xca}!6\x88\xe0\x8b\\L\r\x13[h\xdd\x90\xd8&\xdbqm\xa9l)\xbd\xb3\x0b\xb0M\xba\xc3u}\x1a\xb8\x8d'\x88\x18\x91n\x8a\x88\xb6\xfazL\xa2\x1f\r\x9d\xa3R\r\xbe\xf6\xafEz\x89~\xc4\xd3]", b'\xd2\x91Z \xad$$\xfc\xce\xa0\x98\xd6$\xb3\x16\x891a\xc9\xb3\x98T\n\xb4{rhS\x01\xa7s\x83TgS.\xd6f\xe2\xda`\x93w%\r\xdeJ6s;\xe0\xa1\xd2\xc2D\xbdC\xae\xe1\x0e%;\x9d\xcb', b'i\xd5)\x16\xc27u\x16K\xc9;X\r\xac\xbb\xbd\xc0<b\xea\x97Zi\x95\x02\xf1\xf4\x05Kd\xed6F\xcf4\x19\x98^/O\x1b\xc9:\xe3A`\xadLH\xfeE\x87\x1a\xb1@6<5I\xf1\xcaCZ\x9e', b'k\xc3p\xd8\xfd\xa7\x03|\xed\x89|\xb0\xd8!\xeb4B%kzq\xa1\x94S\x98\xd3\x0b@\xa4\xbe\xe2-\xc5\xa3\x06aR\xf0\xe5\xbe5\x19\x8e\xccZ\xeb\xd2)\xc7*T\xe2\x14\xcfoH&\x88\xc0v\x92\xad\xd8r', b'\x7f\xad\x86X\x8e\xfa^c)*\x8d,&\x18\x16\xeez\x0e\x8e{%\th\xfe(v\xf11\x17\n\xf5\xfa6\xda\xab\xe3AJ\xd5\x16Y\xc9\xfd\xa9\xe9p\xd8\x94\xf2\x03UO\xa7\xb7\xe7`\x1e?_guu\n\x93', b"\xc4\x18\x04/\xe2\xfd./j\x03[P\xf2Rz\x89\xe7;5\xe9|\x1e\xed\x8b14\xfarL\xe5\xb7\x8e!\xf6\xdb:\x91Q\xea\xc4'<u\x01\x89\xb3\x9d\xdd\x96\x9c7\xce\xa8TR\xa9\n\x14\xedC\xe8w~\x90", b",OU#\x16\xa3\x97\xa2\xf5\xb4\x10*;\x8d\x0c\xf4C\x01U\xf4\x05\x81\xb47\xd0>q\xbc\xe1\xf0jQ\xd7f\x11\xfe\xa6V?.\r\xcb\x9aL<\x0fb\xab' \xe4\x15\xc7\xe0g\xa9T\xa6\xe8\xe6\x99n\x9b[", b'\xfcD\xea\xb2\xde\x01\xf3\xfc0>\x8f\xf0\xaeAW\x94\x191\xbe\x8b\x9c}\x16\xae1\xfb\x97H\x00Y\xe7q\x0cw2\xa7\xdb)\xb6nL|\xfd\t:\x84\x02\xf1R9t=_\x94\xee $\x81\x11\xe5/\x97\x7f\x97', b'[\x85\x8c\x10\xc0l\x0f\x96b\xa1\x94\xd0\t\x97\xa3K\xae#Y\xfa\x95\xbf\x18N\x83\xc4\x00\xab\xa6\x9b\xcd3\x02\xbe`\x05d:\x12\x08\xaf\x8eI\x98(\x10\xfb\xf2\xea\x9d\xbc\xd4\x11W~\xae\xe3\xa7\xe7E\x03\xaez\xde', b'\xb3\x83\x8a5[\x16t\xb1L|\x04\x9d\x83\xa2F\xf0\x7f\x8d\x1d\xaf\x9bx[\xe1\xd6e\x9e\x91\xbcCtLmw)\x00\x1b\xb7\xcf\xc0<\x92\xd2\xea\x05\xeb\x7fG(\x1ao\xc8\xb9k\x8b0\x1d\xc7lz\x00x\x81\xfc', b'\x0e\r1\x16\x0b\xd4\xda\x86\x9f\x8d\xbe\xb8L#[\x1cn\xe7\xa5/:\x19<\x08]\xe7\xf7\xc1\xbcj\xa2\xa5\xab\x01\xc5>\x98\xf9q-\x0cf\x96\xa4>Pc\xf8\xaeH\xe1x\xe3\xdaID@;\xed\xd7\xc4)\xaf\xe6', b'0\xf6\x87Pf&\x99r\xbdMGr7\xabg,a2\xdfc\x98\xcc;A\xa3\xcc\x9e\x0b\x9a\xf6w\xdb\xaf1\xb84&\x927rI\x1d\xab\xad\xf3-(T\xf8\xb1\xe0\x11\xd1\xfc\xccd\x9e\xbe{j\x83\xc4j\xa4', b'\x94\xc4\x15\xb0~-\x1c\xddq:\x08I\xdeA\x1f7\xf9\x81\xbc\x12\xbd\x90?3\xe3c\xa4\x8a\xb3m\xfe\x88\xbe\xd8\xb2\x83\x84\xea\\\x06D\x16\xa22\xde\xc0@\x80\xf4S\x0e\xd4\xd3%F\xb4S\xfd\x0e\xf3\x80\xf1V\xf4', b'\xcb\xb3\x91\x9d\xcd\xe0\xfb\xde\x84\x86\xfe\xb8u\xecX\xa4\xf6.mgi\x00\xb6\x9e\xcf\xfa\x8f\xc7]\xf9^\xd3\xc9\xb9f\x11\x1f\x9fb\x8f\xa6\xe8\xd9\x97\xeb\xa2q\xda\x1fS\xa5X\xa5F]\xd2*\xf6tD\xce|a\xdb', b"$\r\xa8\xa8i\x92\x05\x99\xe8\x1dt\x89\xf1U \xfc\x85F\xffx\xbfw@\xb5?\xe7\xf6\xb2\xc9\x90%\xe2w\x93\xb0Izb\x86B\xa1zN\xf6\xe0B\xbd \xcb\xcd\xac'\xa1u\xcb\x14\xc9\x01\xb4\xbag\xb2a\xee", b'\xd8Z\x8c\xe0\xdd\xad \xe79\x01:[\x8fR\xb9\x13\te4\xd0\xa4\xa82\x00\xc7\x07\xe23\xe2\xc6F\xe0\xb6\xef\x82\xca7\xe3*\xb7\xf2/\xba\x81\xd4i\xac\xa1\x01\xc6@c\xe7\xf8\x02\x9e\x01\x95}\x1cE\xd2\xf7\x16', b'O\x1dBF6L\x9eZ\x1b\xad\xcf\x08\'\xee\xb50\x9a s\xca\xa1\xb3\xbd\x02\x8d"\xcc\x82<|\xa4\x93\x03Ra\xb37FAN\xa0\x1e\xe68\xc8\xf6^\x15\xe6\xc4\xefk\xf9\x92]B\xceC\x10\xe1\xa2\xeam\x1f', b'\x1c\xdd\xb0\x0c\xb2\xffR\x01K\xde\xcan\xb9\xd50\x1b8\xbc\xac\xacN\xfd~1\x86\x9ai\x19\xa2\x08\x11\xefPat\x88\x0f\xe0\xd6\x8a\xc1gfY\xb6\x0f\xd0\x9f\xf0\xb8\x15\x1eXFv>\x80\xbcBB\x0f\xf4\xa7\xd4', b'\xdc\xc3*\xc2N\xe4\x103&;\x15\x7f\xd1h\x88\xa9O\x8d:\n\x91V\xcb<\xd4\xd1\xb5\x9b3\xf8\x88\xad\xdd\xccQ\xaa\x08\xef\xbe\x89>\xf0:\x1eW\x8e7\x11\xa4\xd2\xe6\xaa\x8a\x98\xd5\x89V\xb1\x08\xe7x\xe0\xa0\xe1', b"\xa8\x19\xeaK\xcde\x17\xc6\xbai\x93\xda\xe3\x7foF<\x9e+\x96@o\xe0\xf1r\xa5\xb1\xe5\xfbR\xa7.\xce\xef'\x91A\xe2\xf9\xb5p\x01\xf8\xbc\x08\x0c>\x92\xe0\xb4\xb2:*\xb82\xea&\x8e\x07#\xb0\x9f\xd9\x02", b'J\xa0\x8c\xf0\xa28AZ\xd2\xc1*!\xe2\xec\x0f\xfa\xda\xc3x\xf4\xed\xde\xb2\x89n\x05\xa7\x0c#)\x9d\xab\x16\xb6(\xa2|-6\xed\xda1\xd6HU\xaa\xa2nLA\xfda\x15\xe7\x9b\x8a\xa0F\xb3\x14\xf3\xcb\xdby', b'\x99\xbb"l_\x82\x9b\xa5\xb73\xf7\x99\xa5"ZH\x0f\xcc\x98\x99\x91\xd7\xa3M\x01\x1aQ\x9c\x1b\xaa\xfck\x0c\xff\x13^\xa5\x8a\x0c\xc7{6\xed\xc0\xe8\xed\xfcS\x0bN\'<\x1a\x04\xfe\xcbc\xe1\x07{\xb3\xe0u\x84', b'\xdf\x0f\xe7I\xb2Vt\xbf\xd1v\x1e\xe0Z\xaaK?\x8aR\xfe\xa7&\x9cu\xcei4\xe54\xd7\xeeG$V\xc4\x88\xa7\xb5\xe8\xd3\xfd\xec\x97\xd8DT\xf84\x9f5\t\x93\xdf\x1e\xf5\xa7\x03\xe0\xd9nA\xdb\x96f\x1a', b"Z\xbb\x9f\xa7\xeb\x1c\xd6e\xc1\xac\xd0\xe8X\xe0\x81\xc85\xab\xcc`\xa8\xd1\t\x10\xb7\x0eg\xe8\x97\xa9\x17\xc9O\x8d\xfa\xa2\x1b8\xfd'\x02\xe8l<\x98]\x886\xd43\xbe\n\x9b`\xe8g\xa9\xc4D\xb5\xa64j\xf5", b'\x0e\xba\xb7\xc3\xca\xc4n\xfc\na\xba\x08\x86\xab\xc5\x8e\x94\\\x15+:"\xbe\xef65\x1d\xb8\x14U\xfe\xaa\x85\x96 _JS\xcb\x8c\xad\xeb\x02\xef\xa1rVG\x13\xef/\xb9<\x15\xbc\xba`t\xe7\xb5\xcb\xa3\xe8\xe9', b"yR\x02\xe9\xe5\xe4\xf5'\xf8^\xca\x0b+t8\x81\xd8r\xda\xf2\xedd\x0c\xedT\n\xdf\x83\xcfI\x13\x9f\x97]p]\xc9\xd0]\x98\xbf\nP\xcf\xcd}\xd2m\xed!c\x8f\x03\x00\x90\x9b\x9cckr\x1d\xb1C\xe7", b'n\xe5\xf5\xafCZ\x06\x07x\x8ch\x8e\xa6%]uvx\xca\x07u\xdf\xbd\x9d\xdf\xb2\xe8\xb5Pa\xd3\xa4\x88?\xd1\xa7V\xd8\x19\xfd\xbb\xff}\x0e/\x01\\\xdf\x83\xab\xc7\x15\xbd1A\x8e\x18\xa5O\x99n\xa8\xe5\xcf', b"a\xc4\xad\x80\xc6\x98r\xde\x03E/\x02H\x90\x95P\x8d\x90T8\x05\x94s\x87\xc2'\xd3\x0e\x1aZ\xc8?WiB\xf1\xfa\x15^\xed\x93\x99G\xbe\x00b\xa0\xf7\xcc\x85|\xabB\xaf\xab\xd6|\xed\xaff\x87\xf1\x8cX", b'\xe6\x95\xb6\xda\xf4\xc4,\xd8\xeb\xa7\x89\x1a\xb69\x95\x1f\x00\x9e\x11\xe1\xa9\x16h\x96\xfaI\xda?X\xedI\xa1\xee\xed\xf5g\xaa\x18[J\xd6\xbb\xeex\x9ff\xac\x8cyf\xf3/\xa5\xad\xdd\xff\xa5\xd0@\x16[\x7f~\xe5', b"\x8bXZ\xeaJ\xdcW=A\x10H5\x17\x8av]\x1d\xec\xe3\xd0\xf7\x8c\x970\xcef\xe2h\xd1\x05\xfb\xf6\xdd\xf8-\x03\rQZ\xba\xe4\xbe\x00\xf8\xddG\xa9\xba\x1c'cGto\x83I\xe8\x0cJ\xa9X\xf7v\xed", b'\xef\x13E\xa4\xe5;n\xc4Z\x8b\xa1\xaa\xeb x~\xf9]\x98\xa63V\xf8v\x18+]\xc3\xdb\xda\x1c\xb6\xb8\xb9\xa9\xc6\xc1`\x11L\x19\xd4Z9\xb0\x81\x94\xf6\xc8m\x94\xe6T\x1d\x9eYSSwF3dU\x9d', b"\xd0\xa9m\xa3\xf4\x12]\x8e\xbe\xd8_\xffr\xd9~IP\xfau\xf5\\\xf0\xf6E\xca\xb3k\x16:\x15Z\x1e\xbb\xbd['\xba\xd0\xe9\t\xc24O9G\xc0\xe3\x16`W|\x876s\xf4\xff\xe7\xfe\xc99b\x0598", b'J\xffy\xceb BF\xac\xf3d\xe9\xa9Go A.@\xb0\xd8\xd07pD\xf5,vX\x14\xc3UY\xa6\x17\xb9\x84\xbe\xe6\x01/\x91\xadk\xc7\x1f\xc3\xc9\xf6\xbee\x03G\x1d\xc7\x89\xb5s\xe88\xe6q\xfa\x87', b':c5C\xcb\xb1\x88\x19\xa2\xf4\xf0;W\xc6\xad#\x00\xd2\xd4=\xfdF\xab\xa9\x1e\x1a`iZ\xeaG\xedt;\xc9\xf5\x9ag\x07f"\x91M\x18"*zY\x05\x94\xc9\x7f\xbc\x11\xce\xd5W\xde\xd9\xfax\x8eUQ', b"\xdf\xcdt\xbc\x9eRyLW\xc2\xcfre*'\x8cS \xbaLeN\x055\x0f5FU@\x9e\x85Z\xe16\xd7U'q\xcfv\xa3\x07}w<\x851\xf9N4\x9cP\xf9u&\xadN\xcf)\xb5\x00\xcc\xdc\xd2", b'\xbe\x82\t\x8b-\xc4\x07Uj\xdd\xefU\x1d\x13\x14\x0e,\xe4\x10\xddk\xfd\xc0Ww\xb6}\x1d\n\xa7\x03\xa4\xf4\x92\x9elF\xc9\x8c\x10\x0c\xbb\xc6\xe2\xd7,\x14\xfc\xa7P4\x80\x84d\xd8\xe09.R\xf0\xe7\x10\xea\n', b'\x98\xcde+\xb8:Dhm\xa4,\xa4\x9d\xee\x89~K\xec\x93\\\xbb[\x05\x10Z\xcf:\x02#L\xd1\x0f1\xafN\xec\xebJ\xfb\x13\x97Tg\xfc, \xb1N@nU\x14\xfa\xdc\x81\x91N\xe3\xb4\x91\x14.\x1c\t', b'\xd9o\x17\xdeE&b9\x06\xc49!*3\xf6P[\x17Y\xb2\x009\xdf\xa8sTS\xed\x82\xf3\x8d\xca\xc1\xff\xfd\r\xd1F\xb5\xcbS\x95\x8e\x10\xb2\xd2\x9bv\xd4\x86\xe8Sr\x8c|`\xf6=\xe0\xdd}\x18\x8c\xb8', b'\x97\xd4<\xea\xc0\xff=C\xaa\xfd\xde\xa4\x9c\x01\xae`\x0cv5\xa7\x92ug)\xe4\x93C\xec\x9a\xbb\x8c30\xab\xdd9\x16\xa2tI\xbd\xe0\xcd\x8d\xe4\xe4\xce\x12\xf9dix\xdeE\xba\\m#!\x175\x12\xe0\xd2', b'*\x11\xfd\x02\xff*Z|\xa2\x8e5 \xae_\x06\xd3\xa7_\x12\x92\x05*\xddG\x9f\x05\xceK\xadS\xe7a|\xda\xa6\x8b6r/\xcf\xe1\xef\x16\x90\x91\xc4~\xea\x9e\x1f\xd9y\x06-\xbe\xddJ\x02\xd6bh\xb9\\\x94', b'\xf3\xf4)\xef\x98wM\x85%\x98\x95\xe4\xa19\xcb\x08\xaf\x15M+\xee\xdcE\xad\xab\x1a\xbc\xe0\x15h\\|\x81\xbaq\xdd\x10\xe6\xc9\x80m~\xd5\xee\xe4\xb1\xdac\x96\x80)\x08\xcc\xbe#N\xea\x12\xfa\xb9\xb63X\x8d', b'>\x01\\\x96\xb3F#\xe2}\x8c=k,}\x1c\x94\x85J\xabx\xf7M@&\x0b\xf6\xf7\x16\xd4i\xdc0\xef\xc2\xdb\x8b$\xe0\x16\xd7\x9a\xbb-Z\xc8\xd1\xef\xbc(d[\xe9\x91\xd7\x18\x19\xf8\xa1~}\xa2\xc3\xb9L', b"\x07\x0b\x99\x87!)\x88\xa4\x9c\x07D\xe0\x19\xae;{\xf9\xc6nzb\x84\xc9%\\(\xfd\xc4P3L\xc3\x19B'\x16k\xfe\x13\xfa\xeb\xaf\xd7t\xf0Wg\xa5\x98=\xf3\xd3$\x15\xa7~\r\xc5\xd4*\x05\xe6r\x8e"]
# P2 = [b'5\xc0\xeb$\xad\xeb\xc1\x81\xec\x1c\xea\x9f\xdc[\x0e\x92f\x17\xe59\x83\xb0\xa3\xdb\xe0\xbd\xf0p\xe0\xb0\xf7[6\x1c\x8f\x05\xa1m\xa8\x8e0>\xcf\xea\x81\x044-\xf6\xce\xdb\x1b?\xa7\xde\xef*\xee\xd3ZY X\xdf', b'|\x89\x91 \xe7&{\xbb\x87\xce\x8a\x93.^\xaf;\xa1\xc4\x03\x023_r\xf3\x08\x17\xa7}q\xdc\x1e\x1b\x0e\xbb\xda&\x1d\x0c\xd4\xb0H\xc4\x9b\xc8\x15\x8cLf\xf0?\x84\xfc\xa8\x17)\x1b\xa9v\xf3\x95\x86\x874\xb1', b"\x10\x88 \xabZ\xff9{Ls\xaf\xf6\xe7\xd7\x9c&\x15\xa3\xd6)F\xc0YWzw1M\xd6\xc9(dE\xae\xcd\x80\xc6z\x1f\x17\x05\x01*\xfe\xf6\xd5Da\x89ML\xe8)\x7fd\x14=\t\x0c\xc1'\xaf\xe9\xef", b'\x93<\x96\xc4\xda\xa75\xd2\x9drD\x08\xc4i y\x89\xe7\xa4\x88<+\x14\xdd#\x06\xf4TZ\xd2\xb4\n\xaa\\\xc04n\x89q\x14l\xbc\xa1\xea\xaa\xedF\xd9\x17B\xe1\x14Meu\xa5\xaf?\xb5{\x06\xb2\x1c\xd0', b'\xbdd\x11Ok\xb8\xb7p\x8a\x88*-dm{G\x9f\xc8E90pK\x8c\xfc\x0e\xe50\xb5\xbaDD\x19\x9f2 H/\xcd\xd6\xeb\x01-\xd4\x85\x9e\x90l\xa8y\r\x08\xca\xb1\xaaW\x8e\x0b\x84\xd3&\xc2&\x97', b"a\x93\x01n\x9fO\xa5\x13\xfeG\xfa\xeb'\xb2o\xcfAx\xa6\xf1\x8a\xc5\xc9\x1d\xe8\xa8\x8fb*O\x00\x9c\xcc\x93F\x12X\x15\xa4<\xe6\xbd\xe9\xde\xeb\xb5\x11\xe0\x18\x97Y\x1beD\xb3\xc4\xed\x01\x1aV\xcf\xe7p\x8f", b"a\xcc\x87l\xf2\xe2\xac\xa9\xf3zvG\xb0t\xb3X'\xbbX\xdd\x19J\xddv\x9f\x11s\x02\x1aAe\x98\xe4\xecj\xba\x05^o\xd3?\xae\xa9n4\xff\xa7w\xadMi$\x14}\xf9/\xe7\xf93\xd1\xfa\x04\xaa#", b"'\x05\t\xacbb\x01Dx\xf5\x03\xb4\xe6\xa6g\x89\x85\x81Hn7p\xc1\x0bO\xedqQ\x959Sf\x8b\xf7\xdc\xf4\xd1\xeaD\xbc\x07\xdc4P\xe1\xd1\x18y\x17<\x94\x0eJ\xfdO\xa3l\x17u\xba\xff\xa5+\xe4", b'\xf0r\x86\x1f\x08\xf1?\x97\xbc\x1d@\x82\x8d \xd9\xec\xf9|p\xbe~\xe5@\x81\xd7.8J\xbaA\xa6\xb65\x81FVkxs"\x88D;\x87\xab\xd2KJ~|\x8d\xa9\xe5[\xbb{\x12\x88Rz\xe8\xb1\xb9/', b'^to\x1f7\xac\xfe\xffg\xba\x0e\xfe\x05\xa9G\x1d\xce\xf0<\xff\xef\xbf\xb4\xd2\xa5\xdd,\xee\x1e\xae\xbfK,\xda\xc8vy\xaf\xf9N\xc4U\xa9@L\x13\xa7et#9\xfe\x9a\xa0\xcf\xb7f7\xe3\xa4\xfdR\xbc\xcb', b'\x7f\x1d\xc4<,`\xc4c\xa3\xe6<\xcb\x9b\xef[\x80\x19V\x17\x0bC\x99\x8eG\xd4\xbck0b\xb3\x8f<\xca\xebc\x17B\xe9[t\x1bXZH \xfa[\xe2o\xbc\xd60\x9e9\xf87\xb8\x13f\xcf\xdb\xf4J}', b'\xcb,\xeby\xbc\x848\xea\xce\xc5\xc7\x87\x0b\x18\xddY\xcf\xf1(H3j \xfe\x95\x8f\xc7\xd322\x7f\xef\xde\xa5\xb9\x01S,\xbdV\xd4\xe5\x9cK\xa3\xdf\xda]C\xb0\xae5x\x8c\xf6\x1aW\x10\xac\xf4e\xfb\x07\xc7', b'+\xfa\x9a\xb9\xa7\x02{\x99\xe9\x18\xed\x8a\x1bs[?\xf9\xb2\x8e\xec\xdc\xc3\xfa\r&\xeb\xa8e\xaf\xeat\xc3 \t>b4\xc2\xb8\x16\x1c\xb2\x86D\x8d\xf9\x0bd$\x18\xea\xd7/\xa7\xb9\xa3\xd4\x8aK\xe5\x81oG\xca', b'\x9bX\xcd\x95m\xafWP\x1eX\xa1\xea\xbd\xe8(xz\xfes-4\\S\x85\xdb\xa2u\x9f\r\x10 \x1e\xcfPa\x92\xf7\x82\xf4Wag F\xf0\x18\xcb\xb6\xb5\xb3\xc2\x7f\xef\xec\xe5\x9dA\x0cT\xd8\x0e\xad\xa8\xca', b"-\xf7'\xfe\xb6\x8crv\x00\xfebPe\xba\xfb\xb0\x15n\xad4Zj\xe7\x1b\xa5\x9eh\xf3\xbf\x88\xd7d(M\xe6\x1bs\xda\x1e\xbf\xcb\xd0\xeb\xbb\x80\xa71\xa9\xe8\xe5[;\xd5\r4\xb0|\x91\x98\xba\xf6t(\xf3", b'y\xa6\xf3, \xdd\xf0\x00\xdf\xb2UC3s\x14\x9a\x0c\xf7t\x97y\xd3\xeal\xe5\x1d&\x8e\xd9\\i\x8b\xea\xa8m\x1b\x98^\xdcs\x9b.\xd5\xb8\xfb\x86\xd4\x93\x80\xad\xf7G\r\x87\x1fl6+XV$\xb8\xe4\x11', b',\x05Et\x8b\x13c\x98^yl\xac\xaa\xe9\x8f\xd5A\xfcd\xb6\x02\x05\x8eg\xf3]o\xf3DTC\x0f4\xa2\xda\tX)r\xc9\x13\xd6\x8f\xb8\xcc\xeeV4K+\x8b\xa9\xadp\xc4\xc2=?\xb2\xf3\xdc\xc9\xa1\xec', b"\x85\x9bD\xe7\xc6'\xf6]\xb8\x0eE6\x85\xfc\x1ft\xb2*7w\xd8B\x9cW\x7f\xd2\xf9\x19\x16\xc8\x0cN\xdb_\xaf\xd6\xf0\x9f\xeab\xb2\xd2\x8c\xddt\xb9\xe8\xbb\x81\xf2t\xc8+\x8e@:+\xbe\xdf\xf2\x9f\x08%\xbc", b"2\xbb\xcdj\xcfo\x1d\xf9r$\xd4\xc7\xe7q\xa5z6\xd4\xd3\xa6'\x18\xff'e\xeb\x14\xd2\xe7\xc2\x9aXn:\xe0[\r\x86/q`\xeb\xdc1\xe1\xe6\x92T\x17\x98x\x85\x97\x9b[\n\xaf9\xc0\x0b\x05\x0c\x01\x8e", b'\x06+\x1e\xad\xc1\x06=LBO\xd0\xf4l\xaa$\x87\x8f6\x9e\x00\x9e\x98\xcb\xb3&\x19}\xb9\xaa:^\xcbM\xbd\x9a\xf3c\xbc\x84/\x9eF\xdf\xf2)\xa2\xbf\xdb\x17S\xbfS+\xf5\xf2\x9c\x90\x96\xcd\x13\xb0\x1a*\xe0', b'\x8e\x1d\x1a|=q\xfc\x95Z?\xc6`\xc9\xb6\xf1l\xf2\x99\xa2\xf2~V(\xcb2\x93\xd8\x0c\xbf\xec\xb8\xba~zjx\x1eg%\xf3jhC\xc54\xb1\x985\x9b\x98\xf9G\xea;\xab%\xbf\xc8<83g\xfd\x90', b'\x8b}M\x91\xd9yg\x8a4\x808\x01\xba\xb9\xa6\x19\xccr0\x8a\x1b\xf56\x13\xbf\xe1\xe7\xd4\xe7j^\xfbt\x18\xdc\x1b\x95yJ^\xb7\x1d\x8fk<\xa9-\xeaW\xa8\x17d\x9c#XN\xb0\xbf\xf4\xc9\x1ec\x91\xee', b'\xaau\xd1\xb1\xe2\xf8\xbf\x98\x00$5\xb5F\xac\x03\x94c>N\xa6[]\x8d\x1fKUh\xeeb\xa7\xf8\x1ag\x89\nUo\x81\xa5{\x9d\xe8I\x84_\x18\xa9\xe3\x15g>FT#\x1cD\x83aA\xa5312\xf0', b"\xed\x004\x18w\xc38+\xd9a\xc7p)<AFpf\x12O\xc4-f\xces(\x18\tuz\xe6(kx\x14K\xf4\xf4\xbb\x94\xd0\xeb@'t\x1c9\xb8\x00F-r4\x1a\x04\x08z\x81\x03\xb4\xc0\x0ey\x8b", b'O2\xea\xa3Z\xf5\xdf\xe9\x1f\x87[\xb3\xa0t\x84*\x13P\xf4 \x17r\x1a\x1e\x10u\xcd\xdb\xdd\xf0\xc4TiVg\xaf\xc6\x96\xc6t\x1d+\xaa\xe4\xe9\xa4;\xb7-\xaa\xd7\xf4\xe4\x80A\xc9kQ\xc1+\x0c\x0f\x8a\x9e', b"f\xe89#\x89\x1c\x96\xde#H-\xf7\xbfH\xa9\xe8\xef\x05\xd3\xda\xd3\xbc\t\xde\x8euo\xb1\x9e|\x91\x86\xa8|1*>\x85\x13vi(')pi\\4\x0e[YZl\xba\x15ru\xc4^\xb0\x81\xca\xdco", b'\xcc\xb7\x00\xb8\xa5\xea\xf4dF\x14g\x00n\xd7\xd8\xc9z\xd5\x08\x14\xcd9\xb8\x9ah\xc3B\x84\xd4\x1f4\x11\xe9\x13\xd2yk\xe9n\x1c\xd4\x8a\xab+$\xe4\xe0\n\xe43Q\xfc\x1c\x03\xb6\xdc\\SL\xc7\x93\xba\x19\xaf', b'7\xd0x`\xe7^v!\x87\xdas\xc1<\xea\x0ebqq\xeb\x8f\x9c9\xcam\x8c\xd4H\xda\x1c\xc2T \x90\xa7\xb5\x10\xa9/\xfaN7{\xd6xa\xe4F;\x82\xaeH\x9e\xd6{,\xc3\x81\x1aj\x08M~6\xbb', b'/\xc8s\xb0\t\x86\xd9\xfb\xe43=\xd6\xccA\xd6\x9b3\xc4\xdcSQ\x15\'@\xb9^8]\xdf\x8d\x00\xe8\x85\xde{o\x95\x83\xddE\xde"4U\xfb%\xa0H\xa7\xb2\\1\x19l\x81\x1d"\xac>*,H\xe9\xee', b'`\xbb\xdf\x8b\xf9\x16\x81\xe4\x00\xb5}T\x00\x06\xe9\xd9b\x19\x1bC\x12\x9c\xb4x\xdax\x14s\xcev[\xf4M\xc8"H\xa3w\x1a\xd4l\xeaVi\r46\xfe\xaag\'\x96\x06\xc3"\x8b\xc8\xe2\x84\xf1\xd2z\x97Q', b'\xbd\x0e\x96!\x87}5v\x9c?e\xfeZ}\xe8~w\xe6\xfbn @2\xdf\xe4\x9cH\x97\xd7\xdc\xd0\xaf\xef<\xce\xff\xad\xc7\xd42\xd47\x16T\x96\x0bx\nc\x05\xe6h\xb8A\x16\xd4\x00\xb40,k\xc0\xdd\x93', b'\x89\xae@.C\x99\x054\xd0\xf9*x\xe4\xa3\xfe\xec\xcfV\x85\x93\t\xd5K.\x98J;#\xc7\xde\xa7\xe3j\x1cs\x13c\xda\x01\x14\xeb\x17\x0f\xba2\x14\x08\xde{:\xe2\x14\xee\xca\x05\x93\x94\x1a\xf3y\xd8\x0e\xaf|', b'oEt]\xd7w\x8fmo\xcdf\x15\xe4e>\xf3\x0b\xaa\xf2~\x13\xa3g\xbc\xd1\xa8[O;\x88\xf32s=W\x80\x01\x03o\xb1/\x95\x04X\x8ce\x84}\n\x00\xd0|\xc0\xf5fZ\xef\xb2\xd2\xa7-p\xce\xc4', b'=\x9aO\xa7\xb3\x9f\x1e\xb9\xb4\xf3\xa1\x93U:\x0b\xe9\xff\xcfB\x8b\xc9\x95\x81\x8f\xb9\xa0\x8f\xd9\x01\xdf\xb8\x10\x1e\x19\x9f\x9f\xd4\x89\xcb\xf4\x9f\xac]\xc5j\xad\x9f\x02q\xb0\x17\xee\xa0|&\xd7\xd4\x9cH\x0b\x81\xde\xca\xec', b'\x15\xc2\x1d\xb8\xe9\x88\xa1,\xfed\xd6\\\xfa\x00\xd0Rj\xfa\x04\x9f4/2\xf6\xe5\xac\xba\xb2\\\xd8U\x9b\xaaE\xea\xa5|b2"\xd2wA\xe6=\xe7?\x06\xa2*\xd9]T\x80Gp\x15=\xb4\xe8\x99\xb0\xd1\xb7', b'\x84\xb1\xa5\xa2]\rR\xa1\xcb\x1bK\xc0\x80@\xa0wx0\x92\xac\x934\xae\xf1\x96\x8f\x8fG\x9a\x15mj\xe1\x96T\xbb[\xd2\x89L\x8c\xc9\xc3\x1d?\x16\xf6\x9b\xc3\x86\xf6aD?A\xc4\x84\x89\x01\xdd\x16/\xbe\x92', b'~}\xf7\xf5V?\x9du\xdb\x93\x99\x9b\xc5\\8\x1eh\x168\xe0D7\x93M $%\x8dF\xf5\x08\xf8\x953E\xa2\x88kt\xe3-\xcd\x86\xcce\xeeK\xc6+\xc2\x1e\xbc|\x11$!\xe0YK5\x8e\xdb\x82\xbc', b"\xe3bl?d6W\xe3\x8c\xd7(g\x95)V\x1dKFObm\xf7&u&/\x9d\xd4*R\xe2[\xd5K\x14\xad\x02YxH\xcb\x1d\x1b\xee\x81\xa5\x89~'\xd7\x1a\x19\xbcXv>\x1f\xef\\\x85\xd9b\xa5J", b'W`\xe8;\x8eKA\xe1\xd1X\xc1\xee\x1eE\x9d>>\n\xf0\xcb\x94\xddCm+{C\xe2\xf1\xb5\xe62\xa0\xa9/\xb5\x02\xe9l\xf7Y\x06\x9d\xa2Rcw\xd0!\xf3H\xb8\xcc\x14\xd0\x8d|\xba-\xf9\xb8\xfe\x94G', b'y?#\x11Y\x07&\xb1\xd3\x85\xbfO\x97\xca\xee\x0b?P\x18\xbf\xe3\x84\xbd\xa7\xc7\xee\x8d\xd1U\x92Y\xbf\xa9E$\x01.QbSi\x1b\xb0\x8f\xf1\x01y\xd8\xc7\xc8\xd1\x89\xf7\x19\xfa}\x9e\xfb\xd3\xd99\xfc\xedt', b'\t\xc4\xef\x94\xab^\xc2\x96+\x93\xfa\xb0\x82=\xb6"\xf5\xa8\xb3\xa9\xe1\x8c\xe2\x1e\x1e\xe2\x0b\xc5.0\x927\xfc\x9b"u\x12o\'P\x94\xb1\xe9\xc84\xff\x0e\x852\x1f%\x11\x0fv>)\xfc\xb88(\x85\x00\x10\xee', b'Mx\x180\xa5\x1b\nN\x1c\xc3X\x9d9\xd9.L2U\x94UAM\xe2\xd7N\x94f\xe2\xc2\xb1\xea\x95Q\xe57\xc4\xf8#\xfc)\x07i\xe2\xb2e\xc8R\xdb\x1f\xe3\x00e\xbe\r\xcaP\x0e\x9f\xda\xc8\x1fYe\xf7', b'U\x18\x00i\xa7\x1e\x96\x8a\xc8\xf3^\xc8\x08~\x96\xf8\xa3\x0fL&D\x94vDD\x86\n\xca\xc9\r\xe4\x13\x1cV\xa6\x99\xa2h#?c\xe1\x98\xe8\x10\xa8\xa2CF\xfa\xfct\xa3\x12\xd2Fm\xbb\xde5\xea\x93\xc4\xe9', b'\x14\x04m\x1e\x1bP\xf5\xe2\x14"\xc8e\xe1\xd5\x86\xd1\x97\xeb\x91\xdc\xcc\xf7\x8b\x1f;x}\xe7+\x8b0\x96\xad\x11\x95\xd5Zr\xaa\x16u\xcdu(\xd2;\xf2l\x03\xce\xeak\x10(\x8c\xbb\x91\x12\xa0\x82\r?\xc9\x84', b'\xe7h\xd0TG\x85"\xf9!\x11\x80\x0b\x9d\xefg%\x8a|\x19\xd0Fq/\xf9z\x1c\xd5\x10\xa7u\xde\xc7\xb5"\xed}1,z\xd4|~we]HJ\x17\xdf\xbb\x04\xe1L\xb5\xe6H\x1d\x84\xd5\x15\xc1\xfe\xa0\xc3', b'3BR\x9d(\xcaox\xce\xd4\xd0o\xa5\x17\xca|\xac>\x92f\xe5\x87\x89\xe1\xb5m_!\x8a\x02\xa2J\xca\xb2\xe3W\xd6\x15a\x0f$\xaa\x07\xa2|\xa5\x83\x15m\xc9b\xa2%\xacOr(\xbf\xefC}\x86\xa6\xfd', b'\x01!\xf2\x8f]\x13\xa7\xfd\t\x829\x85\x8c&\xa1~\x97\xb5\xe2QdM\xb1>\xaf\xa8\x86h]I\x13\x7f@\xfa\x0c6\x1a\x80\x19T\xb4)\x9d\x97j7\x95z\x97\xc9\x92\x8a\xd5\xc2Q\x86u\xf7\xd0\x83d+\x12\x94', b'\xe1;\xd2\x0c\x9d\xd5\xc4j\x87\xcb\x88\xb4v\xd6\xee\n\xaf\xdf\xe1\x1f\xe4\x9b\x86>\x0e\xf0\xa9\xab\xa9\xd4`\xee\xd0\xa7\xcd\xa7\x11J\xe57\xb6\xd5\x93\x00\x8b\xf9!\x81/Q[\xd4\xd6\x95`e3\xa0\xd5\x0e\xfa\\!\xcb', b'ST\xe9\xee\xbe\x1bn>+\x03\x01\xc0\x96\x07I\xe8q\x00\x94>(N\xd8\x84\x13\x8a\xff*+\x16%T\xb4\x12\x9a+\xf3\xec\xe6_u\x0cp\x18\x07cC"\x13C\x0b\r\x11\x03}\xebk\xe9\xf9\x8bZ\x87*\xde', b'\xe8\x8a\xaa\x86\x1b\xfco\xae\x16\xc7\xdb\x89\xd1\xa9p\xbf\x17\xe9\xe2\n[Dx\xc9e\x7f\xa5\x84w\xf0\n;Pjv\x0eW\xbaV\xff\xec\xcd(\xe6U\xec<\xeb\xb5|\x1f1\x00&\x029\x1c\xbfj\xd8\x1c?\xb5}', b'\x94\x95o\'\xe0\x97&\xc4\xe0\x88\x1eh\xf1\xf9\xfe\xaf;\x0cT-\x87 \x8c\xe8\x19GE(|\x10\xfbw\x00\xa3&\x03\xe4`2Z4s\xf6\xd4`\xd9#2#\x19\x14\xd4O ")X\xee\xbf\x9e\xb6}\xbb\xe6', b'\xbbH\x1ep7<Q\xd4\xed\x8d\xe6"\xb3\xa1\xf5EIM=\t1]\xa2\xdb\x7f$\xbb\xb1\x97u\xf7\x1b\x10\xf8\x82\xc7\x8ce\x84\x80-\xff\xb2)\xab\x87\x1c\xf2\xaf\x84\xa2JP\x91\x7fp\xd2\xe0\x11\xa4\x8f\x10{(', b'\xa1\x94C\xe2\x8c\x932w`x+t\xbe\x97\x1b\x89\xed*\xa9\xe81\x82\xae#\xfc\x87\xe3\xfb"&\xfc\xb4=I\xe3\xe0\xae\x99\xc9\xe5A\xfaw\xaaO\xf7G%\xab\xcc#\xb8\xa4\x1d\'\x1c\x0c7~\x03B\xbeJP', b'\x0bF:\x92LC\x97\xed\xdei8{\x1cn,\xd8\x8dWm\x08b\x08\xe1\xec\xbf\xb3\x85U\xa9$\xf4\xe6zL>\xe8\x0bs\x8a\xa4\x868\xc4\x05t\x94\xbe\t \xfe\xbd2gj\x11\x97\x00\x9f^d>\xbf\xa3!', b'\x876;\xc7x\xe3\xfd\xaa\x0brKkU\xaf\xce\xd0~\xad\x9f\x9bF}F\xcb>\x15\xdb\xfb\x7f\xf9\xc8?d\xe0\xfb\x92f\xbe\x02O\x99\x95\x08\xe4\x86cY\xc70\xebkhg)\xd2 \xc0w\xad\x8f\x1d\xb1\xf7\xb3', b'\xe0\xf8v(\xde\x85\x84"Wx\xd6\x00\xed\x15\x1c\x9a{\xb5\xab\x07\x07\xe4-\xbb\x82`\x80\x9ah\xc5\xe7\xdfTU\xa2\xe6\xa5\xc9U\xb6\xb8\x83f\xfeU^\x91\xa9\x83\x9cE\xc0\xa4\x19|"n\xfa4\\\xaf\xac\xf6s', b'\xd9\xba3\x8b\xdd\xd6\xba\xf9\xc4\xe7\xa3\x88\x9fx@\xbf\x91\xc7\xdb \x9cP\xa6\xa5\x91\xdc\x80\x12x\x9f\x88\x82\xb0\xab\xab\xf9\x02\xb0\xda\xb90#\x8a\xe6mO\xa0?H\x16D\xaf\xff\xeb\xbd\x94\xf9\xa0\xab!\x9e\xb0\xdf\x83', b'RN\xb6\x8c\x8c\xb1\xfbs:\xd1\t\x06sMs\xdf\xc5\x91wm\xbav\x95f\xdb\xbc\xc4\xa0\n\xc8\xbc\t\xbe5\x92\xbc\x08e\x88r)\x1b\xad\xe2\xa6<!\x1f%-9a7"hA\xb9?\x9f\x81}H.Z', b"\x88o\x85\xdd\xa7\x18$:7\xef\xce2\xeeS\xce\xa1C\xad\x0f\x85\x81\xc92K'\nm\xe6\xb6\x98\xb5Q\xc2\xea\xcdl9\x9c\\\xae\x1bu\x8c\x83\x15\x11\x9e \x80\x00y\xb8h\xce\xaa\x83\xf7\xd8\xf2\x12j&\xfb\xc0", b'\xd9As\x14\xbd\xbf\xf3\xaeu:\xce\xa9\x85^\x00\xe7\x9c\xde;\xef\xf6\xa56t\xa8Q\xc2\xbf\xfap\xd3\x82D\xe8\xdf\xbea\xf8V)\xa8\x80\x7f\x14\xe9\x9e\xef\t\xcby\xb5\xcb\xbcs\xb7\xa6\x7fj\x99\xbft\xee\xee\xcf', b'\xb8\xa8\x84\xf9\x9bFV"\xedk\xb3${\xcfDl\x19\xf12=\'p\xb3\xafd\xd5\xf2\x81$\x17$\x10\x92*\x8eyx\xa9r\xa2^\xd5\xa7\x8d\x1f"\xbb\xc1(\xf6\xa9\x00U\xe4\xbd\xa94\xe1\x94\xec\xb4\x0e\x01\xb3', b'\x1d\xff\xd9Uh/m\xdfOE\x0e\xaa\x04w\xccY\xbcLy\x1238\xf0\xd7\xd9~\xef\xfb;,\xad1s\x02\x8e\x7f%\x93\xce\xa22\x12\xef\xb3\x07\x1a\x965\xea\xbe\xcd7\xad\xbe\x0c\xcf\xab\x1f\xa1\xd3)\x82\x18<', b'9?\x95\x0f\xa2W\xe5\x97\xe5\x87\xdf\x08C\\\xd3(f\xd3k\xf5Ui\x7f-e\x9f]\xf2\xfacx\x16\xeb\xc5\xbe\xf5 \x0f#\xce\xb4\xbc\xbc=)W\x88Y\x94jh\xb5\x0f=\x9c\xber\x842\x9fo\x08K\xe3', b'\xfc\xc9\xeb\x87\xbbu\t8\xe1mC\xdd\x94\xabugGc\x04\xe2\xad\x0c1\x13\xf1\xaf0]\xfcnC-\xbf1%NW\xead*\xc6\x1dOC\x10\xef\xf3\x87\x93\xf2\xd4\xa8\x96\xd7vr\xec\xc1\xe8\xad!\xd6\x03Z']
# L1 = [b'+\\\xf0/s\x86\xef\x91Zuk\x1d\x0b\x00\x8f\x07\x8a\x01\x97\x8a\x8b_\x99\r\xacc\xabT\xd2t\xa9\x8a\xc8\x92\x19~\xabl\x18\t\xd1[J$\x1bE\xd6~\x05\\\x90\x0b^:\x87[\xb4\xba!\x97\xa3\x8c\xe0V', b'JFZ\x0b\xab\xac\xd5\xa3IU\xe4\xd2\xb3\x97\x1c\x15*\xe9\xa1\x87\x01\xf9\xfd\xd7(z\x0c\x14\xf3{\xc8\xfa\r\xaa7M\xf8\x81U\x9a\xb9\xbf\xfe\x05\x99-`d/\xca\xdb\xbd\xc5C\x19YM\xe8\x1c\x04\xef\xb6<\xca', b'\x8a\xab\xf3W#\x93\xaa\xb00j\x8e\x8bI\xad\xcb&\x15\x0bj\xbf\x05\x1cn\x1e\xc4\xe6|\xe2\xbeo\x98\rHB\xee\xae7\x06\xe4\x80=\xfcK\x9c\xe4|*/@\x83\x1b\x84_\x0f\xf1x\xa3\xa0(]\xc9"z\xd7', b"\xc3\x1b\x91\xe3\xe04\x11\x93q\xa8/\x18\x19\xac\x95\x8a&fQ\x9e\xd6\xf7kf\x83\xb7\x90\xcdnt\x1b\x934\xe9\xdb\xf9\x04\xa9\xa2\xeeF\x95}`\x8a\x9d\xd7\xb5i\xa8'\x9aAQ\xac\xaa\x10\x85J9\x15\xbb\x85\xfa", b'>\x7fv\xc0@\x85\x05Kcf\xa8\xf2\x98!${O"\x87\xb8\xb7\x9bY\xb0\xca#Ri?\x8fKPi\x83\xe1\xa6\xff\xb4\xd8\xd9\x17\x83Oi[;\x84\xc9_\x7f\xd5m\x9aj:\x18\x0f\x9a\xc3\x12Y\xcb\x9aO', b'(\xbdp\x00-f\xfa&tG\xcc\xbb\x85\x90\xedZF\x08\xce\xbek\xabF\xaf\xa0\x98\x90\x8f\xbb\x9f[\x13\x01[\xa4\xe2\x80\xfb\xab\x15\x87\x1e\xb91_5(=Q\xcdw\x07Fa{\xd7\xf4\xd4\xde\x11\xc9_\xb4\xc8', b'\xbb\xb1D\xe6\x9c\x9b\x1e\xb1\x13\x17\x1e\x03\xf7R\t<LE\xccS\xd2\x1a\x9f\x97e6\xb2(8\xa9H\x01t\x86\x13\x05\x0c\x97\xb6\xd5\xa1_Xxm\xba\x00\xa5\xbc"\xd5\xc7\xe3\x17\x1d\xf5\xb1\xcf\\0\xff&\xfa\t', b'\t\xab\x10\xb4\x9e1\xa9T`\xaf\x10\xa1\xe4\x9c\xf7Q\xe5\xf5\x8e\xa8V\x82|\x18\x95\xad\xa1\xe1\xf9\x12vHm7 i\x19y\xa5\xe9s\xe9\x0c\xb5\xd20hC\xff6\xb3h\x98a\xfbW\xd0\x04\x96D\x17\x87\xee\xbd', b'\x82\xfb\xc6o9&}\xfa\x9f\xec s{\x80\xc5\xe32(\x0e)Ixr\xdf\xe5RF\xb5\xe8\x14\x8f\xd4\xd3\x06O\xc0<\xe37\x02\xfcc\xe5\xe1\x91\xc9\xf09\xf9\x9f$\x17\xe4{\xcb\xfce\x90Av\x1f\x81|2', b'\xf2=\x845\x9d]\n\x89c\xaeX\xa7Gb\xad}\x85\x0c\xab\x92\x89=\x0bx\xbb\x1a!\x8bB\xff\xf1\xb9\xb3\x9aU)$\x03/}+yJ\xd5\xb6#xK\xab:6\xaf\x18& 6f\xd6\x9d\xa6\x16\xab@\x1a', b'\x8e!\xe2\xb1\xa9l\x02\x9di\xd87\x7f\\\xfe1\x89n\xe5y\x07\xa4a\x93\xd5A\xae\x81N>\xdf\xf7(&\xe7\xf8)a\xbc\xb6\x00B\x82\x0eo\x87\x08\x8f\xe72\xc1\x18\x1e1"\x99(\x89\x90\x84\xec;\x1b\xeaW', b'k\xa1M5m\xce\xfc\xf4<=\xdak\xc1\x1b87\xd8l\xec\\h\x13\x95\xf7?\xa1\xd8\x8bgN\xf6\xfa\xc7\xe7d\xce\x9fF\xc2\xbfl\xbbY\xba\xcfc\x15\xc3^\xce)\xcc\x0f\xba\xe0"<\x88\n\xad\x12\xb3\xb7\x0b', b'\xa4;\xce\x97\x8b\x8a\xa0\x96\xcb\xbb\xaf\xb2\x93\xfd\xeb\xf8B\xf9\x0f\xe4\r\x06\xe7\x10$\xa2$\xe3\xc2\x06v\xd4\xd8\xab\x88\xd6\xe7\x00k\x82u\x19\x9d\xd1;\x0b\xafk!v_2y?\x99\xe8\x1a\xab\xb36\x0e\x1a\x9d\x0f', b'L\x82\xc8^\xb9\x85)^\xaaL\xe8y\x9c\xdcn1\x0c\x17\x10\xacV\xc1M3\r\xe4D$\x82\xb1H\x1a\xed\x98>A\xc9~P/\r\xd8\x07\x80W\xcd\xd1\'j", \x17\xfc\'\x1eu\xb1\n\xe0L\xaee\x9a', b'\xb8\x90\xe4\xa8.\x8a\xea\x05$~f\x16\xe5[\xe9\x80*\xcaY\xfcF\xd1\xf7\xddYq\tix\xa8\x86\xcb{\x9aK\x98\x1c\xcck\x00\x0f\xbf\xc3\xda\xc7\xa4J\xbd\x96\xec\x1e\xf7$\t\xb7s\xd6\xa0\xdc\xaa\xd7\x0b\x01O', b'\xdd$\xe2\xad\x9b\x12Z?\xcb7\xf1\xf9\xe1\xccg\x9at\xeb\x8bc\xcb\xac\xa4\x93\xa7\x88\xb4\xe9[\xb2\x8d\xd2\x94$;\\9V\xf9\xf4;\x88\xddYh\xe4kd\r\xd1\x8bvm\x0c\xbe\xc5\xe2\x1d\xe7\xb7\xb3\x96\x17\x01', b'\xfd\xf6 \x92\x84\x88\x1cy\xe7\xff\x13t3C\xf8\xd7\x97[I\x14=\xee\xc8\xcfp\x02\xa6\xbdm14\xce\xdbC\x95\xd6d\rJ\x12\xc8/\xde;\xc9\x0c$\xdb3\x08\x8f\x8d\x87\x1c\x07\xae\x87\xe5hB\xd1\x0cv\x82', b'\xaf:\xb0!1aK\xc9]\x9d\x08R\x15+\xc1"\xee-\x1b4.\x178\x9b\xd5\xd2\xe7\x9a\xdd\xa8\xcc\xbb\x8d\x0e9\xa07~\x89\x03Cy\xf3\xaft\xef\x82\xc2.\xfa\xe5\x8c\xce\xeeer\xdf{\xabw\xedQ\xca\xeb', b'\x85\xd4\xd7x\x80;\x80\x19!\xffHk\x0f\xa8ko\xe6\x040\xe9e\xb5\xfcx\x8bRQ\xc8\xcd\x85\xcau)\x10\xc4C\x18\x7f\xcdTm\xc0\x1c\x10\xa3Me\xd8:\x0e)\x94\xc7d\xc8\xcf\xc2\xca\xd5x\xefY\xed\x85', b'\xb3l\x90\xe0\x86`{\xd3\xa2\xca\xd2\xd8\x89\xe7\xdf\xf0\xf9\xec\x1d|qN\x8aM^w\x98\xf2W\xf9@\x7f\xc9{|\xf5V\xa0\xca\x83C*\x13X\x94\xc8\xaf\xdbzm\xa4\x1a\xd2 {,\x89\xae\x1f\x90\xf1Pk\xd0', b"\x07\n\x01\x19\x04=\x92\xac\xb1\xb6c\x0c\x16\x1cAK\x80\xe0RZ5\x03\xd7)h\x19\x9cF\xff\xf9u?\x88X\xb1\xd5\x97\x01AUh\xcf\x8ab\xb8\xba~SDP\xe1\xc8\x90\xba\xdf(!X\xe1\x11',\xf9\x98", b'\xb6\x9a\xfatj\x0b\r\xd1\xb9\x95\xc9\xbd\xefO\x87Z\xd2<1\xb0N\xd2hq\x0c\x1bl\xc9\x04\xb0\xbb\xe1,\x1e9\xf4\x936P\xdbz\xb7^\xfd\xd4Q\texV|\x9e P\x93\x05\x18\xd8:\x06\x83\xf7\x82<', b'\x0e2\x8f\xa7\xb0,\x04\xe1\xdf>\xdd"\xce\xa4\xf4\x90%\xbc>\x9f{\xecc]\xbcTD\x96[\x18d\x85\x8b\xcf\x7fV\x02\xc5\xb1M\x17d\x17\x91\xa0v2G,\xf1\xc5\xb9-O\x12\xd7(\xeee=\x0f\xe2\xb5\xae', b"\xb7\x89\x03q\xde\x93\x82\x15;\x0e\xcf\x95\x8a>V\x8f3\xb4\x1d\x94a6Bz\xe4#\r\xca\xf6\xd7\x18\xaa\xc9\x10\xc1b\xa4I'\x91F\xd9\x89%\nqh-Q$\x16\x0b\x14/\xe3F\x9c\x9a\x06G\x87\xffe\xb5", b'\x00\xf0\xe1\x99(O\x8e\xac\xb2\xd7s\xa0\xc7\x98<\x89\xc5\xfce\xa63\x94\xb2\x03\x03\\\x01\xca\x89^)(\x00F\xd0\x81a\xc4!\xa7\xa6\xbc\x16\x0ea(\x11\xb2\xb3;\xd7\x92\x13_,\x98\xedsa\x06\x85\xc3\x0b\xd7', b"\xe4l\x14\x97\x8f\xea\x06?\x8a\x0c\x87\xa8'f\x1e\xce\x05O\xc8\xedO\x9f\xa3h[9\x99\x1a\xb4\xbd\x8en\xd6\x81\x8c\xea\x1fx+r\x0bq!~\xff'\xefi\xc3\xf8\x11\xf1\x88+w\xec=\x12\xa9\xf9}\x87\x8aJ", b'\x8f\x9e-\x86\xc0\xbdp\xbd\xf8SW\xd3\xde\x9a\x9c\xa4/\xbcw\x99\xb2\x1f\xf1\x86\xc4\x91\x06;\x8f\x981\xb4\xef^\x9a\x87\xb8\x97/\xd1\x9c\xedc\xa01\n\x0b\xd9\x1f\xe2\x92\xb6V=\x1cc\x81\xb38\nG\\\xa0\xbb', b'w\xa5m3af\xad\xa6>>D\x1d\xa3j\xfd\xc4I\xea\x1d\x99\x85\xfcQ\xde\x07\xfc\x07\x16=}\xe2\xcc\xbaS\xa4\xe7\x81\x9b\xd6\x90s\x06\x01\xa1S\xd7\x01.M4\xfe\xaf\xb6\x0co\xe8C:\xa41L%0u', b'\xf5h N8\xb8eh\xb8\xffp8\x82\xbf\x9b\xde*\xd8[\xc2@\x18\x80\x87\x1a\xb0\xa8S|4\xac\xfe\xf5\xaaj\x89\x12X\xe0H\xf9\x08\x8f\xad\x1b\x7f\xfd\xf8q\x9e\x82\xc8\xeb\x9b\x84\xe0}\xc3\t\x17F\xad\x88\xc8', b'\xd7&K\xc2\x86A\xe5\n\x1da\x0e\x97\xe7\xdaL\xf5\xfe\x1862\xb8\xd1%n\xd3\xed\x19\xff\\\xff\xfbM\x1a\xdd\x8d\xaa\xaf\xb9\x14\xaa&Gf\xfa]!\xcc\xfa\xa37\xd46\xda\xc8\xe7\xc0E\xb9D`p\xc5\xb5\xf1', b'`\x0c\xb8{b}\xa7\xef@\xe1\xb2\x93\xabk\xdf\xb1\x12\xa0\xcd\xf9\nn1\xbc\xdfQE\x9dC\x08q\x94\x1e\x12oh\x96\x98\x9fT\x07\x8fJ\xbf\xe7])Z\xe7,\xa0\xb1\xbe\x1b\xf2\x01\x8b\x0c\x0c\xdc@\\\xd9J', b'\xb0\xfd\xb1\x08\xaf3\x11#\xfcW^\xaf\x1d\x15\xd3\x92\xc8&6y\x89\xa7\x0fo\xf8?\xa9\xccU\xac`\x89l\xf8:\xeb\xf6.(\xdd\xb8V"a\xf0=0!\xe3nr}\xb1\x92\xb1\x1b}[>\xaf\x1f\xc3\xa5Z', b'\x9a\xd6Ei%\xcd\xa0\xc0N9\x8f\xb3 \xe86;\xdf\x9f!yw\xbd\x87\x98\xa6\x8cgb\x17\x9b\x10\x1d\xdd\x96\x04<kK_\xe0\xa2\xe5Q-\xf1\xc6\x1dB\xcdK`cC\xdb\x1cIxU\xc9iG\x81\xd7\x92', b'9E\xe6\xf7\xdb\xcbRy\x10\x91\xce\xd2\xe1\xa9\x939\xa9#$\x11\x1c\xe7\x93\x84\xe2$?\x81\x1ft\xc9\x80\xad\xf6S$f\x06\x138\xa3\xeam\x82dC[\xc1\xf2R^}\xed\x1du{\r\x8cv\x94JZ\xd30', b'\x91Y=\r\xbd\xc2W\xe9\x17\x16\xd6M\xd4\xb1s\x86\xcc\xa3\x86\x04\xaa\t2~c\xae\nr\xad\xe0\xb6\xb6\x81\x01\x1d\xe2\x80\x81v\xbex&\x84\xa7\xfb\x83\x03\xa6\x84\xd7}\x8c\x85\x8e\xb4tN\x8a\xa6\x1a\xd1\xef%&', b'\xce\xc6\x87D\\\xe5\xd0\x97\xf2\x84c\x80D\x19\xe5\x97\xe5\xb1.~\xf7\xe6\x99\xac\xb9\xae:\xf0\xad\x00\x93o\xc4M\x17D 2\xd6\xa7\x9a>\xb1\x8e+\xd7\xa6\xa1\xb3\xa9\x0b|no\xfam\x9e\xd3I\xb0\xef\x86\x9aT', b"\x11iIT&5'>_\x0e\x7f7j\xad\x9f_\xfb\x95\xa1\xdf\xbc;\xc9\x96\x02d\x18]k;\xbd\x0e7L:8\x07\xed&\xf4\x10\x846s\xa0\xa4K\x0f\xcc\xc0\x8f\xafB\n2\xde\x015\x96\xc3\xe6\xcf\x1e\xf3", b"\xd8\x8d+?\x144\xfd%)B[\x04\xba\x81\xa3\xcat\xfeb\x83\xe5T\x11\n\xdb\xe8f,\xd0\x1bbZ\xcc\xf4\xa9\xc7\xa6\x8dN\xd1\xc0v\xe8\x84\r=l\xcf\x14&\x84\x0f\x00\x18'F\xca\x05\xcd\xab\xc1\xc0z\xaa", b'\xde\xd1q\xeeXU\x02\x1e\xf6\xe5\xf8\xf2\xc3\x14\x1dD\xcc\x07\xa7\x06\xd9l\xb7\x89\x1f\x85\x16l{\x02\x84\x9d\xb8\xceH[\x0c\xbfN|EE\t\xe6\x9dLC\xa9\xe3\xf1\xdc\xf52?\r4\x90\xe4\xad\xb4\x14x+\xaf', b'\xe9\xcc\xb6\xd8:l\x0f\xe8Qm\xdc\x02\x8a\x8d3S\xf0\xb8\xcb\xab\xdc\x1c\x1az\xcb\x87+\x95\xdd?P~j\xca\x94\xa2\xde\xd1Nq\t\xbe\xd4g\x02\xb8QZ\xc3L\xd5nb\x90\xbc\xeeWqJ\x8e\xc0\x81\x15\x06', b'\x04\xfe\x07\xed\xbb9\xf4\xb0bXT]\xe1\x8eTJvDH\xf4\'i"YZ\xfc\xee\x13\xb7p\xa4\x8a/\xeb\t\xea\xb1\x1b\xd5\xa7\xe1jH\xe6\xa4]\xdd\x8b\xf7\xf0\x84a\r$\x19\xaa\xd7\xd6\xdf@\xd2\x88mO', b'\x1d\x07i\xed\xdb\xb34\x83\xd0k\xaf\x88\x13\x8ag\xbf>\x0c\xaa\x8a\xca\xbb\xe4!/\xb1\xac\xed\xb7t\x9c\x992\xc5\x1d\x04\xbe\xe1\xb1\xf5b\xa5UM\xda\x19W\xe6\x86W\xcb#\x89\xd8]+\xc9\xe1F\xde\xbb\\\xaa\xf0', b'\xb2\x99\xa6\xcfv\x1a\xae~\x08w\xecl2;\x87\xed\xbc\xb5]\xec\xe7\'\x16p\xfe\xc3#\x8a\x1abt\x99`\xaa\x81\xc6\xae\xf1\x1eV\xe3\x10\xbc\x1542\xf4\x0c\\Kk\xd9\xb2y\x95|?w\xa9"\x02\xb3n\xcd', b"c\xfa&\xc5!\xd2\x8a,\x11\x93\xf0\xda\x9b\xb4kY\xe0\x15\x97\xc9\x16\xa6\x7fF\x7f\x9d\xb2\xa3R\xc1Os\xdeT\n\xe1\xc7G@\xaf\x94'<+\xb4\xa2\xe88\x00\x8d\x92\xc3\xa2\x01\x9fo\xef\x1e\xa4\x0eOi\x8b\x84", b'\x03hy\xac\x0b\trPP\xdd\xd8\x901A\x93\xe5\xa3\x04\x83[D\xc7\xb4\xde\xd1\xa2O\x11\xd7\x01X\xdad\xcd\xe9\x90\r\x88\x98lM\xa3\xd8\x08\x01\xa1\x96\x9e\xa3-F.\x05\xa9[~\x17\x8a\xf9o\xf7\x1c\x9eu', b'\xc8\xef\x11\x1a\xa0/\x8et\xc2\x16[\xcc\xca\xc5\x92P71R\x1b\xb0\x8b\xcfg\xb3\xad+1\\\x93b?\x9fn\xa8k^D\xaf\x0bV&7\xf0\xa0\xf3\xbf\x19*X\xa1\xde\xb7K\x8b\xf4b+\xb5\xdbC\xb5\x11\x8e', b'/X\x0b9f\xd0\xe3\x85\x1c\xa3f8\xe7^\x91\xbc\x1aA)(\xb6\x05\xfd?\xb9i\xa7\x0c\xf7\xc9\x17\x023\xe7^c]\x04jj\xfb\xa2\xa3\x88\x91\x89\xfbCi\xcd\x1b\x01=\x0bP\xb3l\x9f\x0b\xb0;B\xb0\xb5', b'K={\xd8\x9b\xd9\xf5\x92\x86=\xee65\xd3\x8fJ\x1c\x16\x89\x82\x80~\x7f\tI\xcc~\xceC\xf9\xce\xb9UI]\xffU\x92)v,$c\xf90f=\xe5\x07\xf5H?\xe9\x1c#\x99\xef\x08\x92t^\x80\xa7a', b'{g\xc0\xa8\xff\x0b\xb4\x8b2_\xdcF\xad\xf5\xd3\x97\xca\xd4MD\x9b\xba\x99>\x1d\xc48\n\xbb\x17H\x9dCJ\xc27\x17\xa9\xd6\x10,d\xd6\xbe\x03\x0b)@\xb1Q\x8cP\xbc\xe3\xe0\x8e[\x8c=bcR\xe0P', b'\xc8\x86\xef=`@*\xb0\xcdF/\x0eK\xeen\x06\x11\xfcXmeW\xe4\xe4\rG";\xf6\x01[\xc7\x0c\x8dk\xa8\xd3\xe5\x14\x85\xd539\xd1\xd3\xf3k\xdb\x91%$ax\xda\xf5\xa3.\x0b\xe7\xe4\x18\xcb\xcc\xdd', b'\xaa\xf1\x8a\xf0\xf0^u\xb2x\x95\xf8\xbf<R\x90\x97\x88\x15U#:o\xac\xe5\xceF\xd4\xec4\x1fSS\x04\x01\xc0\x82Q\x9a\x8b\x83\xcb\xe7\xf6\x14\x8c\xe4CG?\xd7\xb3?\xa4\xae\xbeN\xbb\xbd\x8d\xd1J\xb5\r3', b'\xdb\xf2u\r\x9f\x9a\xb3\x86\xedG\x11Y\xbe\xe6*]\xec6\xd8i\x98J\xe22j\xa7Y\x8d\x8d|3\xcb^\xb3\xa8\xe75G\x04hm\xea\xb7\x00\xdfk\xfdf;\x05\xd8\xee\xccRr\xe9O\xad\x83\xff\x01O\x15\xbc', b'^9j\xdeX\xed\xc6\x8c\xc5\xccp\r\xa0\x87[\x08z\xc20\xbb\xa1P\x92b\xca>\xea$\xff\xdf\xea`\x95 ?A/\xb8\x03|B\xd8H\x04\xc9\xfc\xba\xa7\x81\xbe\x92\xdc\xa8`\xab(\xee\naF\xa8\xe1\xa4\xe5', b"b\xd2\xb8\\\xe0\x88\xb8lV\xba0>\xc3\xd6I$\xcbT\xd1\x99\x8b\xd7\x86\xe3\xf3=/\x80\xfc=\xc2\x91\xf5\x10\x9aE\x9b\xa6\xd3\xa8K\x82\xd3'4\xdb\xdb\xf7=\x92\xaa\xb4\xdb\x05\x81V#\x91\xb3\xa3\x80J\xbc\x96", b'=\xb9@:YW\x9b\xd3\x11\xae9#Q\xcf20e\xf5\x16\x04\xc6),\xb4\xc4`\x11\xd3\x8a<\x8eD\xc6\x97\x1c\x1c\x0f\xb2#\xe3.\xc3\x9d7\xc5\xad\x16\xb7\xd0f\x19!\xe1\xfdnc\x19\x07[\xe3\x93\xae\xad\x87', b'\xad%\x17\xa4\xaa\x16\x06\x0f\x9a\xdeZ\xdd\xa2`\x84\xe7\xf1\xd3\xed\xf2\xb04\x9f\x01\x10d\xf9\xa0g%\xf9a\xe4\xa39\xdf\xbe\x04\xec\xd9\x1e.4\x8dq]\xe0\x11\x05\xa7\x8c\xfar\x8cz\xd5\x05\xbc*\xb7\xf3\xb4\x9b\x8f', b'V\xa4\x05n\xd0=\x1eb\\%\xc8\x08\t\xebh\x12\x19xG\xee{\x97\x13\x94:o\xe4\x80\xffL\xf4(\x83\x937St\xdc\xb6\xd8\x96]5\x18\xf9\xdb\x98.\xb5\xd8h\x1cY\x9d\x9cP\x00\x96\x00\xcf\xca&\x98\xd0', b'\xe6T\xddtp\xc7\xdd\xda\xb3\x0e\x88\xea\x12\xcf\xbf\xd3\xfbA\x84\xd4\xa9\xa5\n$<JUMqr\xd2\xc4n\x10d\x8d\xf7g\xf4\x84}~\x8b\xfet\n\xdb\xff\x10\xa3\xd28w\xdc4~s\xa1\xa4\xec(\xf6\xadi', b'\xabw\xb7|\x86\x02\x10\xb4\x08\xff5\xce"\x05\xd7>7"\xc3\xce\xd3\x11\xc6W5Ou\xf5\xc9/\x86\xb5\xec\xe4w\x1bs\xf7\x84\xc6\x0b`\x8d\xcc\x80\xa6\xbe\x87\x96\xd8[!\x1e\xe98\xf0\\\xda\xc9*\xb5\xdc\xb4\xff', b'\xa7K\xd37+\x0b\xd3\x81\x9c4\x8a\xbd\x90f\x92\xc2DQX\r\xb9\x8b4\\\xe9\x94\x1d\xb5\xde\x93\xc4\xfa\x9d\x1cR\xc8\x9b\xc6\xde\x98\x03\x93\xc12\xa8\xcb\x1a[\xf1\xd8\xd1\x915\x82\xdbi\xd6\x94\xc95\xdd\xf3\xf4;', b'\xb8\x9c\xbd-\rm\xb8dP\x1e[\x9b\xfbT\xf7q\xe7-\xaf\xa0\xf7\xfc\x1b\xd7\x16\xf2\xf4\xd8\x7f\xcfm\xa8\x95\x85\xfa Z1{I\x07\x85E\xf8\xdd\xfb\xe6M\xaa\x04\x97BS\xd0\xb8\xec\xc3\xc4\xa3\xfe\xaf5\x84`', b'\x02q\xb5\xf5\x88a@\xd7\x8b\x8f\xc3C\x08F\x9f\xfds\x9b\x99G\x8d\xd1\x15\xc5Z.G\xeb^3\x06\x8f\n\xe6w\x8b\xa4\x86\xd3b \x9cs\xfey\x0eQj\xddT\x12{\x90]K\x17\x7f\x83\xf0kZ\xc97\xb1', b'\xfb\xd8\xc5\x92\x90\xef\xa1-\x97|\xba,\xbd,W\x01$j\xbc\xa0\x10\xfc0\xc5\xebx\xf7\xf6 \xe5\x12^\xaf$\x82\x1d\x03\xfd\xac\x1c\rA[F\xf5,p\xd7\xdcu\x03)\x92\xc4\xb9\xe1\x17\xe7\xa8\xba:\xe3r/', b'\x97;\xb1#\xaf\xad\xb7\xc9.\xfb\xfa\x8fZ\x8a\xe9C\xe7\xc1\xa726~X|((p\xa8\xa8\x9eX\xd2\xa0\x15\x12\xf1-Il\x86g\xe8d#D\x03\x83\xe6\xafx\xe5h\xa0\xfd\xdenlj\x1e\x9f\xab\xd3\xc4Z']
# s2 = [b'\xa9s\x9e\xdbE^\xab\xef\xf0\x96p}\xd3M\x00\xad\xa5\xb2\x90AyE\xe4,$\x8e\r\x7f\xf2\xecM\x11', b'\xab\xfbE\t\xd8b%\xab\x0e\xaaf\xc6\x11\x85H\xf7!\xbe\x90\xd5z\xfe\xc3I\x95\xde\xbe\xd4\xd0<\xb7`', b'f\x97\xc6; \x16\xedB\xea\x9f\xbeM8\xe8\x86\xd9\x17\xa2y#\xfa\x971\xcdH\x92\x1c\xc1\\w\xe5U', b'jf\x8c\xb0P\xeb}:A\xeez\xbc\xaf8-\x08X\xebi\xca\xe2.\xe3@\xde\xfc\xc7\xd7\xa0d\x99k', b'r>V)\x81\x96|\x87\x99z\xd0E$<\x02\x1ao\x19\x1aV\xa4"\xf7\x1c5\x92<m5\x89\xea\'', b"Ouk\xb9\xb9,\xe1!_\xe3'k\xf8:v\xdfhZ\x85k\xc2@\xd8\xcba\xaf\xae\xd1v\xb4Z\xa8", b'|\x8e\xa2y\xc1\x91\xea\xab2\x89\x15q"\x89q?\xb3\xc8\xb1\xe6<\xbb\x0e\xb6\xf0=\xc8\xf2\xea\xb5\x08\xf6', b'\x1aa\x81\x80\xaa\xc2}\x9f\xf3\x9c\xbd\xc5\xeca\xbf`\xe2\xf1\x0eL\xab\x8aq\x82\x8ekkZ:\x91\xa5\xe1', b"\x94\x9a\xd4\xf6\xdf2\xb5\xff\x0fR\xeb0\xdc\xfd\xb1pl\x08B\xcf7\xa7\xc6\xf1\xfc\x8f'\xe5\xf4\x00\x8e$", b'OK\xbc\xa6+\xb1\x89(M&(\xa7\xa2\xbah\xf0Tu\xbb\xe62P\xb0Gd^l6\x1e\xe3Ym', b'\xde)\xa5c\xd0\x17=xw\xda\xe2n\xb8{pFVa\xdahg\xd5\xa0\xf7\x802_6\xc9\xcd\xb0\xf4', b'\xd6MM\x91\x1fU\xde8\xd2\x02\xe1?\xf8*\xc2\x15+\xfe\x10\xea\xbaA\x03\xc7r\x1b]Y\x85\xff\xa9\x1b', b'K\xbfR+P\xfb\xdf\x93\xa6n\x8f\xe0\xf4`\x88\xe0\xc6E;\xb7\x8a\xa5\xb5\xff"t\x082\xa37\xd1\x12', b'U\xfd.th\xba\xd8\x1a\xf3\xc4Y\xeb\xfa#3$\xc0\xda\xa8\x90\xa7\x9a\x10E\xc3\xf3\xb3\x04\xd6\x06\xcf\xe9', b'\x83\xed\xf7`\n\xfc\r\xdd\x8a\x0f\x9b\x87m\x07\x02\xab"\x9e\xc5j\xf2EP\x82r\xa5\xa5\xb6=\x0f\x14\xa3', b'\xfb\x90\xf0\xb0\xe8)C\xffnS/|\x85\xf2j\xa7ur\x05\xdd\xe8HFW`2\x80O\x0e4\x91\xdc', b'\x98\xf4_\xe9?\xa8t \xcaH k\x1e\xa6\x0c7\xb3w\xec\x14\xed[\xbf\xbf\xb5\xe8\xfeUS\x89o\x8c', b"+\x10\x90aS\x06\xeb\x98?V\xd7\x92Z^\r\x93sB\xba'\xe0\xafi\x80\xf4\xe3\xdbLu\x82\xf2\x96", b'o\n\x1c\x92\xc8w\xc5j\xbbGnI7\x0c\xc2&<\xebL[\x1e9H@c\xff8h7M\xb0P', b' \x91PAo\x8c\xcb\xc3IH\xc6\xbc,!\x10\xf0c\x05\x94\x9en\xa8B\xdbkm\xaf\xb5\xbf\xc8\xcd\xeb', b'5\xc54n \xda\x95h\xe4\xbd\xad\tm\xe7\x80jfr\x1ej\xedO\xb5\xc1 \x83\xb5\xc3\xc8\xbbHV', b'X\xe3\xda\x97[\xf2]\xf6gwa\xa2\xb5\xa9\x90\rL)\x17XA6\xf8n\x7f\xb0R\xdf\x8a\x9b\xe1*', b'\xc1\x9b"U;)\xea\x85L\xeeC\xc6\xa6\xc8a+\xf8n\x00\x01L\xd9i\xd3R\xc1\xf5\xd1\xa7j\xf35', b'G*\xce\xf7\xf2\xdd\xac\xd8\xa6)u\xd6\xf5oj\x9d\xee\xd7\x89\x86/h\x90QI\x1b\xd3\xeeH\xcf\xbd\xa5', b'\xa7\xa5\xe9\x1e+1\x0fx\xd4U\xfc\x92\r\x17\xae\x13\xee\x0f\xb5I\xc9S\xff~\x94\xbeZ\xc8[\x14\xa2\xb5', b'%K\t\x80\x0b\x13(\xf9y_\x8d\xa5Up\xbeeFW\xe1\xd9D\x88\xdd\xe7SV\xf3\xf1\x87Q\xe3\xb4', b'\x9ai0zJx\xa2\xb4\xff\xe5|\xf9vO\xc2\x96FY)1\x92\xfb\xe7\xfd[1\x96d\xa2\x88\xa0\x97', b'\xc6\xdd\xfb\xc2T\xe4E\xd8\xbe\xf6\xe3ef\xa5\xc9\xe2\x0e\xcc\xb719\x94Ay05\xa6\xdci$\xec\xb7', b'\x99Z\x8f-\xc8\x87\xda^O\x0f\x19\x88. S\x8f?\x008\xff?S~\xcf*\xd8[H\xc56\xa5W', b'\x97\x01\x9e\xea\x84\xbdVR\x9b{\xbd\x9a\xd3\x07\x16M\x95AX\x83\xbe\xe1j\x1f\xe3\xdf/u!\xd8}b', b'ba\x18\xbd\\t\x8bc\x9esW\x13q\xeeX\x01\xa9\xf7\xbc\xb9\xa5\x01\xfd\xa4\xeb\xfa*\xe8_\xdc\x9d@', b'\xb1)8\x0f(\x89fD\x05;\xb3\xf2\x1b\x9da\x0b\xe1\x9d\x8d\x8c\xache},\xcay\xec\xf0\xd2\xfb\x11', b'\xaf\t\x0c\x84\x1b\x14,\x04.\\\xcd\xde\xfd\xb9\x16j\x02O\xd6\x7f\x87\xab[!\xa8\x8e\xb2qH\xe6\xc1)', b"\xd0\xa6 \xcf\xddUNN\x99\x1aQ\xf3?\x1bL\xba\xd3r\x1e\x81\x04F\x90o\xecm'uc:F\xb7", b'aR\x00\x8a~\x1cZ(\x18\x01\xdf}\x9b;\xd82\xb1y\xbdN\xdb\xb4tC)\xfd(k\x8c\x8a\xacJ', b'\t\xf83t\xee\x1dB\x89p\x9c\xd8t_>\xae\x84\x1c\xdb\xdbrm\xf1\xder\xf5j\xf2\xc8|d\x03\xbb', b'\x9b\x04CA\r\xaf\xb1\xd9\x84n\x1f\xd0\x04\xa5u\xea\xee\x99\xac\x898\x19\x9a\xf7\xd4\x1aB"\xf6\xec\xa0"', b'\xe0\xe7r\xfd\xab)s\xd3\xa0\xc5-\x93\xf8\x92\xb4\xaef\x86\xfflI\xd1\xa3\xd66\xcf\x18\xcd\xe7\x10A\x1f', b'\xf3_D\x8d\x04\xcb:\xb7J&[&Q\x92\xbc\xa6zF\x13\xf6z\x82\xe13\xc2\xeb\x13\x1e\xd8{\xd1q', b'RW\xe2\xb3i\x8e\xbe\x81\x17gN\xdex\x15\xdf(\xcc\xcf!J\x16\xf3~\xdf\xc8z\xdc\xca\xa8\x0f\xc3\x15', b'\xfe\x1a\xe0\x05`S\xca\x88\xe2\xb1k\xbf-\xf5\xe0c\xec%0\xf7Qt\x8d\x19)\x7f\xf8\x1b\x91\x7fM\xc2', b'I$\xeb\xc7\\@)\xdd"\xe9\x91\x8c#5\x8d\xa0x\x12\xb4K\xdcU\xb9\xf6\x0e\xaa\x07<g\x06H\x97', b'\xa4$\x7f`\x9e\x83s\xcb\xfc\xbc\xba\xb4\x18\xd4sh\xf2DO!\xf8u\xef\xe0\x90\xc7\x12\x9f;K\xb1\xc9', b'\xdd`\xa4Hh\xbdk/\xb6\xc0~\xe6\xe4\x8eql\x93\xd11*h\x00\xdc\xc5\xee}\xd1\x19\x06h\x80\x92', b'\x91\xc7\x0e\x07\x8aV\x11c\xbar\x10\x04vxDHP\xe8{\xecZ\x17l\xcb\x98=\xe6\x0c\xa0\xca\x8c\xb4', b"\xc1\xc0]QB\xa3z'\xf8dY\x904wr\xa316\xe7\xaf\x14l\xd58IVjh\xfb\xb8\xd01", b"\xffB$#\x82\xcc\xa4\x9a\xb7\x0b\x15^4 \x9dK\x19m\xde>\x9bvK<\xb6\xfa'\x15\xdd1N$", b'\xfc8\xafS\x85$\xd2\xb5\x95\xb4\x0c\x83\x86\xd0\xa5\xe1S=\xb8Q>\xd8\n\x9c\xe1;X\xafuo\xdd6', b'\x11\x93\x1a\xf5\xe5{"\xf4H\xea5?~\x9dY\xc4\x00\n\xba\xc5\x9f`\x84`\xd8\x94\xff\\\xbdU\x89W', b'\xf1\xd73X\xe8\xc77Ale\'\xe9\x8e\x96"\xb2*\xcf\xad=\x02\xc0\xdc\xa4\xe1\x96}q\xf2-\x8c\xaf', b'f\xef\xa0TI\xed9\xd5\n\xa0#\xef\x9a\xcev\x88T\x1e\xd3Q\x9b\xbf\xc6\xebWul\xa3l\xa6\xd9\xe2', b'\x81SV(vo\xbf}Q7\ty\xf3\x04FB~4A\xaa#\x8fO\x92ta\x1e>2\x02\xd6U', b'g\x94\x04h\x97u\x00\xb6\\b\x84\x91/\xc2\x8b\x10\xd7\xd1=M=M\xc3s\xe9\xb3\x8a\xdc\xcc\xde\xf8\xda', b'\x10\x15B\x83\x05\xf2iA+\xc7.\xa3\x9fI\x81\xcdgv\x04\xbe\xb9\x89\x90v\xa5/\xce\xda\xd5\x9e`\xe2', b'\xab^\xc3\x06\xf0E\x90\x8cz\xc0\xb3\x07\xdb\xeef\xcb)p\x12\xec\x80\x06\xd98\xecx\xf8{\x0f\x8a\xbdJ', b'\x82\xe9\xe4\x1d:\xd08Xc\xeb\xdb|\x1c5\xc3\xee\xdf\xaa\x06\xf3\xd0\xde&\x1f\x12\x010_\xa5\xa3\xa2F', b'y\rp\xb5LX\xf1\xfd X\xd2\x07\xbb\x18\x90\xc2\xa2\xef\xdb"@\x0f\xb1\xdb\x1cGhA\x99\x11[\x0f', b'1M\x00\x18L\xd0QB\xaf\xdekI\xe5rW\x96\x0fji)\xaf\xd0\x0e(\xfdb\x8fhO\x8bf\xcb', b'\xef|H\xca\xd9\xab\xcc\xce\xfe\xe9%\xe4\xa3\xd8\xbb\x02\x8c\xe4vC\x83\xd0\xb3\x80~\xddU\xe8\xd2Q\xce\xec', b'\x11\x12\xf6{(\x14\xcd\xe1\xfa\xee\xf5\xb78a\xb5\xb6\x87"\xb3\x17\x9c\x00\x0e\xec9W\xf6\xe5a\xc4\x16\xff', b'C\xf9\xc3u\xa3\xcf\x1f\x01\x92U,q\xbc\x19q\x1b\xe4\x96\xe7>\x87a\xaf?\xb8\x16\x93\xd6\x8c\x80\x1eW', b'\x93\x94\x06X\t\xb3\xdeb\n\xba\x11*af\x98\xcf\xb6=\xcd\xee\xdc,\xbf\x87\xeb\xe6gE\x86\x1fKU', b'\x0c\xd9\xd5\xa2S0\xac\xd5\xb8\x7f|P\xeb\x08\x9d\xdc~\x03c\xe1:\xc4\xf3$N\x02\xb9\xec\x121\xca\x82', b'\xb5\xdb3N0@V%]\xfa\xf1\xf9?\xe7\xef\xee\xe8\xde\xdcq*\x82\x9c\xc0\xcdq\xe9\xe1\xa6 ~\xd9']
# s = b'\xab\x066\xe0~\x9d7\x16\x94\x17\xf9\x10a&\xc6T\xb5\x89K\x8a\x95T?\xf7\xc6\x02\xacr\xfaf\xd8\xb3'

# VerASNL(P1, P2, L1, s2, s);

def sendASNL(P1, P2, L1, s2, s):
    print("------ Preparing to send transaction  -------")
    filterNames = ['Log Error', 'Print string', 'Print bool', 'Print address', 'Print uint256', 'PrintStringAndUint(string,uint256)']
    to_keccack = ["LogErrorString(string)", "PrintString(string)", "PrintBool(bool)", "PrintAddress(address)", "PrintUint(uint256)", "PrintStringAndUint(string,uint256)"]
    keccack = []
    for i in range(0, len(to_keccack)):
        keccack.append(connection.web3_sha3(to_keccack[i]))

    filter = []
    for i in range(0, len(keccack)):
        filter.append(connection.eth_newFilter(from_block='earliest', address=contractAddress, topics=[keccack[i]]))

    cb = connection.eth_coinbase()

    P1x = len(P1)
    P1A = [[VerifyingKey.from_string(x).pubkey.point.x(), VerifyingKey.from_string(x).pubkey.point.y()] for x in P1]
    P2A = [[VerifyingKey.from_string(x).pubkey.point.x(), VerifyingKey.from_string(x).pubkey.point.y()] for x in P2]
    L1A = [[VerifyingKey.from_string(x).pubkey.point.x(), VerifyingKey.from_string(x).pubkey.point.y()] for x in L1]
    s2a = [to_int_from_bytes(x) for x in s2]
    results = connection.call_with_transaction(cb, contractAddress, 
        # 'y()',[])
        'VerASNL(uint256,uint256[2][],uint256[2][],uint256[2][],uint256[],uint256)',\
        [P1x, P1A, P2A, L1A, s2a, to_int_from_bytes(s)], gas=99999999999, gas_price=1)
    bashCommand = 'curl -X POST 127.0.0.1:8545 -m 3 --data ' + results.replace(" ", "")
    import subprocess
    process = subprocess.Popen(bashCommand.split(), stdout=subprocess.PIPE)
    output, error = process.communicate()
    print(output)
    print("ERROR: ",error)
    print("------Transaction sent, waiting events-------")
    for i in range(0, 1000):
        time.sleep(1);
        if i%10== 0:
            print(i)

    for i in range(0, len(filter)):
        change = connection.eth_getFilterChanges(filter[i])
        if len(change) > 0:
            for j in range(0, len(change)):
                if filterNames[i] == "Print uint256":
                    print(filterNames[i] + " result " + str(j) + ":\n" + str(to_int_from_bytes(bytes.fromhex(change[j]["data"][2:]))))
                else:
                    print(filterNames[i] + " result " + str(j) + ":\n" + str(bytes.fromhex(change[j]["data"][2:])))

    print("------ All events have been displayed -------")
# sendASNL(P1, P2, L1, s2, s);

# # test()